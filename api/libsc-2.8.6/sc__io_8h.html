<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsc: src/sc_io.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libsc<span id="projectnumber">&#160;2.8.6</span>
   </div>
   <div id="projectbrief">The SC library provides support for parallel scientific applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sc_io.h File Reference<div class="ingroups"><a class="el" href="group__sc.html">The sc Library</a> &raquo; <a class="el" href="group__io.html">I/O</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Helper routines for general and parallel I/O.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sc__containers_8h_source.html">sc_containers.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sc_io.h:</div>
<div class="dyncontent">
<div class="center"><img src="sc__io_8h__incl.png" border="0" usemap="#asrc_2sc__io_8h" alt=""/></div>
<map name="asrc_2sc__io_8h" id="asrc_2sc__io_8h">
<area shape="rect" title="Helper routines for general and parallel I/O." alt="" coords="290,5,380,32"/>
<area shape="rect" href="sc__containers_8h.html" title="Dynamic containers such as lists, arrays, and hash tables." alt="" coords="274,80,396,107"/>
<area shape="rect" href="sc_8h.html" title="Support for process management (memory allocation, logging, etc.)" alt="" coords="311,155,359,181"/>
<area shape="rect" title=" " alt="" coords="573,379,668,405"/>
<area shape="rect" title=" " alt="" coords="24,229,92,256"/>
<area shape="rect" title=" " alt="" coords="116,229,186,256"/>
<area shape="rect" title=" " alt="" coords="211,229,275,256"/>
<area shape="rect" title=" " alt="" coords="300,229,370,256"/>
<area shape="rect" title=" " alt="" coords="395,229,470,256"/>
<area shape="rect" title=" " alt="" coords="494,229,568,256"/>
<area shape="rect" title=" " alt="" coords="592,229,659,256"/>
<area shape="rect" href="sc__mpi_8h.html" title="Provide a consistent MPI interface with and without MPI configured." alt="" coords="683,229,763,256"/>
<area shape="rect" href="sc3__mpi__types_8h.html" title="We provide MPI replacement data types for configuring without MPI." alt="" coords="658,304,788,331"/>
</map>
</div>
</div>
<p><a href="sc__io_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__io__sink.html">sc_io_sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data sink.  <a href="structsc__io__sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__io__source.html">sc_io_source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data source.  <a href="structsc__io__source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad64a224321345ce417f1c2771f522872"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ad64a224321345ce417f1c2771f522872">SC_CHECK_MPI_VERBOSE</a>(errcode,  user_msg)</td></tr>
<tr class="memdesc:ad64a224321345ce417f1c2771f522872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine the MPI return value and print an error if there is one.  <a href="sc__io_8h.html#ad64a224321345ce417f1c2771f522872">More...</a><br /></td></tr>
<tr class="separator:ad64a224321345ce417f1c2771f522872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd4bc6b6a85be1d069eda0898560c7c"><td class="memItemLeft" align="right" valign="top"><a id="afcd4bc6b6a85be1d069eda0898560c7c" name="afcd4bc6b6a85be1d069eda0898560c7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_mpi_read</b>&#160;&#160;&#160;<a class="el" href="sc__io_8h.html#acaac8f61fbf993cb257575379f7e5c76">sc_io_read</a></td></tr>
<tr class="memdesc:afcd4bc6b6a85be1d069eda0898560c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For backwards compatibility. <br /></td></tr>
<tr class="separator:afcd4bc6b6a85be1d069eda0898560c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d454a2d377730cd1bc70bfb8a7b4ae1"><td class="memItemLeft" align="right" valign="top"><a id="a5d454a2d377730cd1bc70bfb8a7b4ae1" name="a5d454a2d377730cd1bc70bfb8a7b4ae1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_mpi_write</b>&#160;&#160;&#160;<a class="el" href="sc__io_8h.html#a1cad9d095f810ac5cb1165b4b9818a1d">sc_io_write</a></td></tr>
<tr class="memdesc:a5d454a2d377730cd1bc70bfb8a7b4ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For backwards compatibility. <br /></td></tr>
<tr class="separator:a5d454a2d377730cd1bc70bfb8a7b4ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24e09d62a26d3f849b112f577158a3d1"><td class="memItemLeft" align="right" valign="top"><a id="a24e09d62a26d3f849b112f577158a3d1" name="a24e09d62a26d3f849b112f577158a3d1"></a>
typedef struct <a class="el" href="structsc__io__sink.html">sc_io_sink</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sc_io_sink_t</b></td></tr>
<tr class="memdesc:a24e09d62a26d3f849b112f577158a3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data sink. <br /></td></tr>
<tr class="separator:a24e09d62a26d3f849b112f577158a3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28782aa073fff5a2b660b420e4bebbb"><td class="memItemLeft" align="right" valign="top"><a id="ac28782aa073fff5a2b660b420e4bebbb" name="ac28782aa073fff5a2b660b420e4bebbb"></a>
typedef struct <a class="el" href="structsc__io__source.html">sc_io_source</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sc_io_source_t</b></td></tr>
<tr class="memdesc:ac28782aa073fff5a2b660b420e4bebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic data source. <br /></td></tr>
<tr class="separator:ac28782aa073fff5a2b660b420e4bebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af3eca35299008feb7e925211732852d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#af3eca35299008feb7e925211732852d1">sc_io_error_t</a> { <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#af3eca35299008feb7e925211732852d1a2b84163511ad25077fe027ec340d7b43">SC_IO_ERROR_NONE</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#af3eca35299008feb7e925211732852d1a2c2dddea0a11434f4886850eaa35de21">SC_IO_ERROR_FATAL</a> = -1
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#af3eca35299008feb7e925211732852d1a4c86e6fff47f44a93f60cc2b96eae249">SC_IO_ERROR_AGAIN</a> = -2
<br />
 }</td></tr>
<tr class="memdesc:af3eca35299008feb7e925211732852d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error values for io.  <a href="sc__io_8h.html#af3eca35299008feb7e925211732852d1">More...</a><br /></td></tr>
<tr class="separator:af3eca35299008feb7e925211732852d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dca7cb70934c421f7e6fac40543a82"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82">sc_io_mode_t</a> { <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82a5167d0f45812185bde0a4cf46d75d199">SC_IO_MODE_WRITE</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82a677a68afab242a8141efa984a5ca2452">SC_IO_MODE_APPEND</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82a23ccd07d4ab6cc418f7b6f036611521f">SC_IO_MODE_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:ab5dca7cb70934c421f7e6fac40543a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I/O mode for writing using <a class="el" href="structsc__io__sink.html">sc_io_sink</a>.  <a href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82">More...</a><br /></td></tr>
<tr class="separator:ab5dca7cb70934c421f7e6fac40543a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b29f5f9ed6b61e7b5672d3098315b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315b">sc_io_encode_t</a> { <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315baa08a7fb5ee22b8a58c990ef676689a6f">SC_IO_ENCODE_NONE</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315baa66f422e2efa443c2d02a8b112614385">SC_IO_ENCODE_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:aba4b29f5f9ed6b61e7b5672d3098315b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify encoding for <a class="el" href="structsc__io__sink.html">sc_io_sink</a> and <a class="el" href="structsc__io__source.html">sc_io_source</a>.  <a href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315b">More...</a><br /></td></tr>
<tr class="separator:aba4b29f5f9ed6b61e7b5672d3098315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1276d327fb08fa6e653e75601c3bcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcc">sc_io_type_t</a> { <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcca9f8320af9147bb482644137c23c8b8d7">SC_IO_TYPE_BUFFER</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcca979ae36e2356c9b5869ef9db91dde818">SC_IO_TYPE_FILENAME</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcca38e65d72498bd27529052aba24c5037b">SC_IO_TYPE_FILEFILE</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcca63d8fbfd9109899c05318191ab95ee54">SC_IO_TYPE_LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:a4a1276d327fb08fa6e653e75601c3bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of I/O operation <a class="el" href="structsc__io__sink.html">sc_io_sink</a> and <a class="el" href="structsc__io__source.html">sc_io_source</a>.  <a href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcc">More...</a><br /></td></tr>
<tr class="separator:a4a1276d327fb08fa6e653e75601c3bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce587b8ebade7a4aed4b628236620f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620f">sc_io_open_mode_t</a> { <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620faf5747afab45df3d2ef2727fc3cf2c176">SC_IO_READ</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620fa35706293af9dc697ce928814db943ec2">SC_IO_WRITE_CREATE</a>
, <br />
&#160;&#160;<a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620fad456fa310244fe36138df7da9c037317">SC_IO_WRITE_APPEND</a>
<br />
 }</td></tr>
<tr class="memdesc:a3fce587b8ebade7a4aed4b628236620f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open modes for <a class="el" href="sc__io_8h.html#aa79491ec78fabf548a23f7cebf3c6f50">sc_io_open</a>.  <a href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620f">More...</a><br /></td></tr>
<tr class="separator:a3fce587b8ebade7a4aed4b628236620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e60ffff939bb6d350246f4c97d9f07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a8e60ffff939bb6d350246f4c97d9f07d">sc_io_sink_new</a> (int iotype, int iomode, int ioencode,...)</td></tr>
<tr class="memdesc:a8e60ffff939bb6d350246f4c97d9f07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generic data sink.  <a href="sc__io_8h.html#a8e60ffff939bb6d350246f4c97d9f07d">More...</a><br /></td></tr>
<tr class="separator:a8e60ffff939bb6d350246f4c97d9f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa622ecff196b59deacaceb17392b1dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aa622ecff196b59deacaceb17392b1dae">sc_io_sink_destroy</a> (<a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *sink)</td></tr>
<tr class="memdesc:aa622ecff196b59deacaceb17392b1dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data sink.  <a href="sc__io_8h.html#aa622ecff196b59deacaceb17392b1dae">More...</a><br /></td></tr>
<tr class="separator:aa622ecff196b59deacaceb17392b1dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659c6c8ed2b84afa02370d24dfa200ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a659c6c8ed2b84afa02370d24dfa200ab">sc_io_sink_destroy_null</a> (<a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> **sink)</td></tr>
<tr class="memdesc:a659c6c8ed2b84afa02370d24dfa200ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data sink and NULL the pointer to it.  <a href="sc__io_8h.html#a659c6c8ed2b84afa02370d24dfa200ab">More...</a><br /></td></tr>
<tr class="separator:a659c6c8ed2b84afa02370d24dfa200ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6162967d2e258b52386566141436fb4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a6162967d2e258b52386566141436fb4f">sc_io_sink_write</a> (<a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *sink, const void *data, size_t bytes_avail)</td></tr>
<tr class="memdesc:a6162967d2e258b52386566141436fb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a sink.  <a href="sc__io_8h.html#a6162967d2e258b52386566141436fb4f">More...</a><br /></td></tr>
<tr class="separator:a6162967d2e258b52386566141436fb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa0eb4519e6a08e80806368af1c5d2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#adfa0eb4519e6a08e80806368af1c5d2f">sc_io_sink_complete</a> (<a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *sink, size_t *bytes_in, size_t *bytes_out)</td></tr>
<tr class="memdesc:adfa0eb4519e6a08e80806368af1c5d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all buffered output data to sink.  <a href="sc__io_8h.html#adfa0eb4519e6a08e80806368af1c5d2f">More...</a><br /></td></tr>
<tr class="separator:adfa0eb4519e6a08e80806368af1c5d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace22410e0cfe7a0ae9700d82067785fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ace22410e0cfe7a0ae9700d82067785fe">sc_io_sink_align</a> (<a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *sink, size_t bytes_align)</td></tr>
<tr class="memdesc:ace22410e0cfe7a0ae9700d82067785fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align sink to a byte boundary by writing zeros.  <a href="sc__io_8h.html#ace22410e0cfe7a0ae9700d82067785fe">More...</a><br /></td></tr>
<tr class="separator:ace22410e0cfe7a0ae9700d82067785fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885f1e2093446b086f1a86013fc401d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a9885f1e2093446b086f1a86013fc401d">sc_io_source_new</a> (int iotype, int ioencode,...)</td></tr>
<tr class="memdesc:a9885f1e2093446b086f1a86013fc401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generic data source.  <a href="sc__io_8h.html#a9885f1e2093446b086f1a86013fc401d">More...</a><br /></td></tr>
<tr class="separator:a9885f1e2093446b086f1a86013fc401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1848d8a873e2e0369a4d8fe3b1093a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aa1848d8a873e2e0369a4d8fe3b1093a1">sc_io_source_destroy</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source)</td></tr>
<tr class="memdesc:aa1848d8a873e2e0369a4d8fe3b1093a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data source.  <a href="sc__io_8h.html#aa1848d8a873e2e0369a4d8fe3b1093a1">More...</a><br /></td></tr>
<tr class="separator:aa1848d8a873e2e0369a4d8fe3b1093a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528524daf7cb8916666ecdc9b1220ee4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a528524daf7cb8916666ecdc9b1220ee4">sc_io_source_destroy_null</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> **source)</td></tr>
<tr class="memdesc:a528524daf7cb8916666ecdc9b1220ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free data source and NULL the pointer to it.  <a href="sc__io_8h.html#a528524daf7cb8916666ecdc9b1220ee4">More...</a><br /></td></tr>
<tr class="separator:a528524daf7cb8916666ecdc9b1220ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a26974dd167da45407fc0e177c7134"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a50a26974dd167da45407fc0e177c7134">sc_io_source_read</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source, void *data, size_t bytes_avail, size_t *bytes_out)</td></tr>
<tr class="memdesc:a50a26974dd167da45407fc0e177c7134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a source.  <a href="sc__io_8h.html#a50a26974dd167da45407fc0e177c7134">More...</a><br /></td></tr>
<tr class="separator:a50a26974dd167da45407fc0e177c7134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6f7717c1f5432845c38723150aa2b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aef6f7717c1f5432845c38723150aa2b4">sc_io_source_complete</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source, size_t *bytes_in, size_t *bytes_out)</td></tr>
<tr class="memdesc:aef6f7717c1f5432845c38723150aa2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether all data buffered from source has been returned by read.  <a href="sc__io_8h.html#aef6f7717c1f5432845c38723150aa2b4">More...</a><br /></td></tr>
<tr class="separator:aef6f7717c1f5432845c38723150aa2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87acd257d6d563918d4289af7376a452"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a87acd257d6d563918d4289af7376a452">sc_io_source_align</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source, size_t bytes_align)</td></tr>
<tr class="memdesc:a87acd257d6d563918d4289af7376a452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align source to a byte boundary by skipping.  <a href="sc__io_8h.html#a87acd257d6d563918d4289af7376a452">More...</a><br /></td></tr>
<tr class="separator:a87acd257d6d563918d4289af7376a452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80e1d5b0874c1cca7a3fe2129b0f7d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ac80e1d5b0874c1cca7a3fe2129b0f7d9">sc_io_source_activate_mirror</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source)</td></tr>
<tr class="memdesc:ac80e1d5b0874c1cca7a3fe2129b0f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a buffer that mirrors (i.e., stores) the data that was read.  <a href="sc__io_8h.html#ac80e1d5b0874c1cca7a3fe2129b0f7d9">More...</a><br /></td></tr>
<tr class="separator:ac80e1d5b0874c1cca7a3fe2129b0f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a387778989363d2ab70e12a94fc6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a428a387778989363d2ab70e12a94fc6a">sc_io_source_read_mirror</a> (<a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *source, void *data, size_t bytes_avail, size_t *bytes_out)</td></tr>
<tr class="memdesc:a428a387778989363d2ab70e12a94fc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the source's mirror.  <a href="sc__io_8h.html#a428a387778989363d2ab70e12a94fc6a">More...</a><br /></td></tr>
<tr class="separator:a428a387778989363d2ab70e12a94fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a561466b45e9164d802e5c09462a01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ab0a561466b45e9164d802e5c09462a01">sc_io_file_save</a> (const char *filename, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *buffer)</td></tr>
<tr class="memdesc:ab0a561466b45e9164d802e5c09462a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a buffer to a file in one call.  <a href="sc__io_8h.html#ab0a561466b45e9164d802e5c09462a01">More...</a><br /></td></tr>
<tr class="separator:ab0a561466b45e9164d802e5c09462a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5d6b9b077707913fc8ebed147f434e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a2b5d6b9b077707913fc8ebed147f434e">sc_io_file_load</a> (const char *filename, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *buffer)</td></tr>
<tr class="memdesc:a2b5d6b9b077707913fc8ebed147f434e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a file into a buffer in one call.  <a href="sc__io_8h.html#a2b5d6b9b077707913fc8ebed147f434e">More...</a><br /></td></tr>
<tr class="separator:a2b5d6b9b077707913fc8ebed147f434e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab4446cc9f9f90cec50e5ed04b9575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *out)</td></tr>
<tr class="memdesc:a98ab4446cc9f9f90cec50e5ed04b9575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a block of arbitrary data with the default sc_io format.  <a href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">More...</a><br /></td></tr>
<tr class="separator:a98ab4446cc9f9f90cec50e5ed04b9575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce3e1eb47da5a3200dcc9554ed6ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a85ce3e1eb47da5a3200dcc9554ed6ab2">sc_io_encode_zlib</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *out, int zlib_compression_level, int line_break_character)</td></tr>
<tr class="memdesc:a85ce3e1eb47da5a3200dcc9554ed6ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a block of arbitrary data, compressed, into an ASCII string.  <a href="sc__io_8h.html#a85ce3e1eb47da5a3200dcc9554ed6ab2">More...</a><br /></td></tr>
<tr class="separator:a85ce3e1eb47da5a3200dcc9554ed6ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa398e72498b16db42b5c73a26089a036"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aa398e72498b16db42b5c73a26089a036">sc_io_decode_info</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *data, size_t *original_size, char *format_char, void *re)</td></tr>
<tr class="memdesc:aa398e72498b16db42b5c73a26089a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode length and format of original input from encoded data.  <a href="sc__io_8h.html#aa398e72498b16db42b5c73a26089a036">More...</a><br /></td></tr>
<tr class="separator:aa398e72498b16db42b5c73a26089a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99317ed3eb0e67c0c8f907ad1d2f00af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">sc_io_decode</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *out, size_t max_original_size, void *re)</td></tr>
<tr class="memdesc:a99317ed3eb0e67c0c8f907ad1d2f00af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a block of base 64 encoded compressed data.  <a href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">More...</a><br /></td></tr>
<tr class="separator:a99317ed3eb0e67c0c8f907ad1d2f00af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfb10dfc461f46c52cd3837ff2e79ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#afbfb10dfc461f46c52cd3837ff2e79ac">sc_vtk_write_binary</a> (FILE *vtkfile, char *numeric_data, size_t byte_length)</td></tr>
<tr class="memdesc:afbfb10dfc461f46c52cd3837ff2e79ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes numeric binary data in VTK base64 encoding.  <a href="sc__io_8h.html#afbfb10dfc461f46c52cd3837ff2e79ac">More...</a><br /></td></tr>
<tr class="separator:afbfb10dfc461f46c52cd3837ff2e79ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef98453c04d4b59cb55afc5719c0273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#adef98453c04d4b59cb55afc5719c0273">sc_vtk_write_compressed</a> (FILE *vtkfile, char *numeric_data, size_t byte_length)</td></tr>
<tr class="memdesc:adef98453c04d4b59cb55afc5719c0273"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes numeric binary data in VTK compressed format.  <a href="sc__io_8h.html#adef98453c04d4b59cb55afc5719c0273">More...</a><br /></td></tr>
<tr class="separator:adef98453c04d4b59cb55afc5719c0273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928b33f964817cd7a4427a6a23195b1c"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a928b33f964817cd7a4427a6a23195b1c">sc_fopen</a> (const char *filename, const char *mode, const char *errmsg)</td></tr>
<tr class="memdesc:a928b33f964817cd7a4427a6a23195b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for fopen(3).  <a href="sc__io_8h.html#a928b33f964817cd7a4427a6a23195b1c">More...</a><br /></td></tr>
<tr class="separator:a928b33f964817cd7a4427a6a23195b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3a70bcfdb82fb2ff9d7dfeff465dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a3f3a70bcfdb82fb2ff9d7dfeff465dce">sc_fwrite</a> (const void *ptr, size_t size, size_t nmemb, FILE *file, const char *errmsg)</td></tr>
<tr class="memdesc:a3f3a70bcfdb82fb2ff9d7dfeff465dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write memory content to a file.  <a href="sc__io_8h.html#a3f3a70bcfdb82fb2ff9d7dfeff465dce">More...</a><br /></td></tr>
<tr class="separator:a3f3a70bcfdb82fb2ff9d7dfeff465dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a395d6f476dc4e2f06bf5ca9d91689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#ac1a395d6f476dc4e2f06bf5ca9d91689">sc_fread</a> (void *ptr, size_t size, size_t nmemb, FILE *file, const char *errmsg)</td></tr>
<tr class="memdesc:ac1a395d6f476dc4e2f06bf5ca9d91689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read file content into memory.  <a href="sc__io_8h.html#ac1a395d6f476dc4e2f06bf5ca9d91689">More...</a><br /></td></tr>
<tr class="separator:ac1a395d6f476dc4e2f06bf5ca9d91689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac5f2f255041819e5b8b95d03526e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#adcac5f2f255041819e5b8b95d03526e7">sc_fflush_fsync_fclose</a> (FILE *file)</td></tr>
<tr class="memdesc:adcac5f2f255041819e5b8b95d03526e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best effort to flush a file's data to disc and close it.  <a href="sc__io_8h.html#adcac5f2f255041819e5b8b95d03526e7">More...</a><br /></td></tr>
<tr class="separator:adcac5f2f255041819e5b8b95d03526e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79491ec78fabf548a23f7cebf3c6f50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#aa79491ec78fabf548a23f7cebf3c6f50">sc_io_open</a> (<a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a> mpicomm, const char *filename, <a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620f">sc_io_open_mode_t</a> amode, <a class="el" href="sc__mpi_8h.html#ab12996c8d5e0684fe6859c81992224ca">sc_MPI_Info</a> mpiinfo, <a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> *mpifile)</td></tr>
<tr class="memdesc:aa79491ec78fabf548a23f7cebf3c6f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a MPI file or without MPI a file context.  <a href="sc__io_8h.html#aa79491ec78fabf548a23f7cebf3c6f50">More...</a><br /></td></tr>
<tr class="separator:aa79491ec78fabf548a23f7cebf3c6f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaac8f61fbf993cb257575379f7e5c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#acaac8f61fbf993cb257575379f7e5c76">sc_io_read</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, void *ptr, size_t zcount, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, const char *errmsg)</td></tr>
<tr class="memdesc:acaac8f61fbf993cb257575379f7e5c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read MPI file content into memory.  <a href="sc__io_8h.html#acaac8f61fbf993cb257575379f7e5c76">More...</a><br /></td></tr>
<tr class="separator:acaac8f61fbf993cb257575379f7e5c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c946193f05156b148e9016aa60a2913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a3c946193f05156b148e9016aa60a2913">sc_io_read_at</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, <a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a> offset, void *ptr, int count, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, int *ocount)</td></tr>
<tr class="memdesc:a3c946193f05156b148e9016aa60a2913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read MPI file content into memory for an explicit offset.  <a href="sc__io_8h.html#a3c946193f05156b148e9016aa60a2913">More...</a><br /></td></tr>
<tr class="separator:a3c946193f05156b148e9016aa60a2913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314f8ea4fd91e10a9ace9d0951175897"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a314f8ea4fd91e10a9ace9d0951175897">sc_io_read_at_all</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, <a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a> offset, void *ptr, int count, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, int *ocount)</td></tr>
<tr class="memdesc:a314f8ea4fd91e10a9ace9d0951175897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read MPI file content collectively into memory for an explicit offset.  <a href="sc__io_8h.html#a314f8ea4fd91e10a9ace9d0951175897">More...</a><br /></td></tr>
<tr class="separator:a314f8ea4fd91e10a9ace9d0951175897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cad9d095f810ac5cb1165b4b9818a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a1cad9d095f810ac5cb1165b4b9818a1d">sc_io_write</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, const void *ptr, size_t zcount, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, const char *errmsg)</td></tr>
<tr class="memdesc:a1cad9d095f810ac5cb1165b4b9818a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write memory content to an MPI file.  <a href="sc__io_8h.html#a1cad9d095f810ac5cb1165b4b9818a1d">More...</a><br /></td></tr>
<tr class="separator:a1cad9d095f810ac5cb1165b4b9818a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5838a147b381f125172eff9baa34a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a3c5838a147b381f125172eff9baa34a0">sc_io_write_at</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, <a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a> offset, const void *ptr, int count, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, int *ocount)</td></tr>
<tr class="memdesc:a3c5838a147b381f125172eff9baa34a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write MPI file content into memory for an explicit offset.  <a href="sc__io_8h.html#a3c5838a147b381f125172eff9baa34a0">More...</a><br /></td></tr>
<tr class="separator:a3c5838a147b381f125172eff9baa34a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b871e4d73c09f21285667391d8aa430"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a8b871e4d73c09f21285667391d8aa430">sc_io_write_at_all</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> mpifile, <a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a> offset, const void *ptr, int count, <a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a> t, int *ocount)</td></tr>
<tr class="memdesc:a8b871e4d73c09f21285667391d8aa430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write MPI file content collectively into memory for an explicit offset.  <a href="sc__io_8h.html#a8b871e4d73c09f21285667391d8aa430">More...</a><br /></td></tr>
<tr class="separator:a8b871e4d73c09f21285667391d8aa430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced91d9486b64399a66ccc794a98545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__io_8h.html#a9ced91d9486b64399a66ccc794a98545">sc_io_close</a> (<a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> *file)</td></tr>
<tr class="memdesc:a9ced91d9486b64399a66ccc794a98545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close collectively a sc_MPI_File.  <a href="sc__io_8h.html#a9ced91d9486b64399a66ccc794a98545">More...</a><br /></td></tr>
<tr class="separator:a9ced91d9486b64399a66ccc794a98545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Helper routines for general and parallel I/O. </p>
<p >This file provides various sets of functions related to write and read data as well es to encode and decode it to certain formats.</p>
<ul>
<li>To abstract transparent writing/reading into/from files or buffers, we provide functions centered around <a class="el" href="sc__io_8h.html#a8e60ffff939bb6d350246f4c97d9f07d">sc_io_sink_new</a> and <a class="el" href="sc__io_8h.html#a9885f1e2093446b086f1a86013fc401d">sc_io_source_new</a>.</li>
<li>To abstract parallel file I/O in a way that works both with and without MPI support, we provide <a class="el" href="sc__io_8h.html#aa79491ec78fabf548a23f7cebf3c6f50">sc_io_open</a>, <a class="el" href="sc__io_8h.html#a1cad9d095f810ac5cb1165b4b9818a1d">sc_io_write</a> and friends.</li>
<li>To write to the VTK binary compressed format, we provide suitable functions to base64 encode and zlib-compress as required; see <a class="el" href="sc__io_8h.html#afbfb10dfc461f46c52cd3837ff2e79ac">sc_vtk_write_binary</a> and <a class="el" href="sc__io_8h.html#adef98453c04d4b59cb55afc5719c0273">sc_vtk_write_compressed</a>.</li>
<li>To support self-contained ASCII-armored compression, we provide the functions <a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a>, <a class="el" href="sc__io_8h.html#aa398e72498b16db42b5c73a26089a036">sc_io_decode_info</a> and <a class="el" href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">sc_io_decode</a>. They losslessly transform a block of arbitrary data into a compressed and base64-encoded format and back that is unambiguously defined and human-friendly. </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad64a224321345ce417f1c2771f522872" name="ad64a224321345ce417f1c2771f522872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64a224321345ce417f1c2771f522872">&#9670;&nbsp;</a></span>SC_CHECK_MPI_VERBOSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_CHECK_MPI_VERBOSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">errcode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {            \</div>
<div class="line">  char sc_msg[<a class="code hl_define" href="sc__mpi_8h.html#a701a295557767b751ad4c02ef027cc83">sc_MPI_MAX_ERROR_STRING</a>];                        \</div>
<div class="line">  int sc_msglen;                                               \</div>
<div class="line">  if ((errcode) != <a class="code hl_define" href="sc__mpi_8h.html#af85726c815d1f0ac16948b3c205a1cf8">sc_MPI_SUCCESS</a>) {                           \</div>
<div class="line">    sc_MPI_Error_string (errcode, sc_msg, &amp;sc_msglen);         \</div>
<div class="line">    SC_LERRORF (<span class="stringliteral">&quot;%s at %s:%d: %s\n&quot;</span>,                           \</div>
<div class="line">                (user_msg), __FILE__, __LINE__, sc_msg);       \</div>
<div class="line">  }} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="asc__mpi_8h_html_a701a295557767b751ad4c02ef027cc83"><div class="ttname"><a href="sc__mpi_8h.html#a701a295557767b751ad4c02ef027cc83">sc_MPI_MAX_ERROR_STRING</a></div><div class="ttdeci">#define sc_MPI_MAX_ERROR_STRING</div><div class="ttdoc">Emulate MPI_MAX_ERROR_STRING.</div><div class="ttdef"><b>Definition:</b> sc_mpi.h:331</div></div>
<div class="ttc" id="asc__mpi_8h_html_af85726c815d1f0ac16948b3c205a1cf8"><div class="ttname"><a href="sc__mpi_8h.html#af85726c815d1f0ac16948b3c205a1cf8">sc_MPI_SUCCESS</a></div><div class="ttdeci">#define sc_MPI_SUCCESS</div><div class="ttdoc">Emulate SC_MPI_SUCCESS.</div><div class="ttdef"><b>Definition:</b> sc_mpi.h:303</div></div>
</div><!-- fragment -->
<p>Examine the MPI return value and print an error if there is one. </p>
<p >The message passed is appended to MPI, file and line information. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba4b29f5f9ed6b61e7b5672d3098315b" name="aba4b29f5f9ed6b61e7b5672d3098315b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4b29f5f9ed6b61e7b5672d3098315b">&#9670;&nbsp;</a></span>sc_io_encode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315b">sc_io_encode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to specify encoding for <a class="el" href="structsc__io__sink.html">sc_io_sink</a> and <a class="el" href="structsc__io__source.html">sc_io_source</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba4b29f5f9ed6b61e7b5672d3098315baa08a7fb5ee22b8a58c990ef676689a6f" name="aba4b29f5f9ed6b61e7b5672d3098315baa08a7fb5ee22b8a58c990ef676689a6f"></a>SC_IO_ENCODE_NONE&#160;</td><td class="fielddoc"><p >No encoding. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba4b29f5f9ed6b61e7b5672d3098315baa66f422e2efa443c2d02a8b112614385" name="aba4b29f5f9ed6b61e7b5672d3098315baa66f422e2efa443c2d02a8b112614385"></a>SC_IO_ENCODE_LAST&#160;</td><td class="fielddoc"><p >Invalid entry to close list. </p>
</td></tr>
</table>

</div>
</div>
<a id="af3eca35299008feb7e925211732852d1" name="af3eca35299008feb7e925211732852d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3eca35299008feb7e925211732852d1">&#9670;&nbsp;</a></span>sc_io_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__io_8h.html#af3eca35299008feb7e925211732852d1">sc_io_error_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error values for io. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3eca35299008feb7e925211732852d1a2b84163511ad25077fe027ec340d7b43" name="af3eca35299008feb7e925211732852d1a2b84163511ad25077fe027ec340d7b43"></a>SC_IO_ERROR_NONE&#160;</td><td class="fielddoc"><p >The value of zero means no error. </p>
</td></tr>
<tr><td class="fieldname"><a id="af3eca35299008feb7e925211732852d1a2c2dddea0a11434f4886850eaa35de21" name="af3eca35299008feb7e925211732852d1a2c2dddea0a11434f4886850eaa35de21"></a>SC_IO_ERROR_FATAL&#160;</td><td class="fielddoc"><p >The io object is now dysfunctional. </p>
</td></tr>
<tr><td class="fieldname"><a id="af3eca35299008feb7e925211732852d1a4c86e6fff47f44a93f60cc2b96eae249" name="af3eca35299008feb7e925211732852d1a4c86e6fff47f44a93f60cc2b96eae249"></a>SC_IO_ERROR_AGAIN&#160;</td><td class="fielddoc"><p >Another io operation may resolve it. </p>
<p >The function just returned was a noop. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab5dca7cb70934c421f7e6fac40543a82" name="ab5dca7cb70934c421f7e6fac40543a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dca7cb70934c421f7e6fac40543a82">&#9670;&nbsp;</a></span>sc_io_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82">sc_io_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The I/O mode for writing using <a class="el" href="structsc__io__sink.html">sc_io_sink</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5dca7cb70934c421f7e6fac40543a82a5167d0f45812185bde0a4cf46d75d199" name="ab5dca7cb70934c421f7e6fac40543a82a5167d0f45812185bde0a4cf46d75d199"></a>SC_IO_MODE_WRITE&#160;</td><td class="fielddoc"><p >Semantics as "w" in fopen. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab5dca7cb70934c421f7e6fac40543a82a677a68afab242a8141efa984a5ca2452" name="ab5dca7cb70934c421f7e6fac40543a82a677a68afab242a8141efa984a5ca2452"></a>SC_IO_MODE_APPEND&#160;</td><td class="fielddoc"><p >Semantics as "a" in fopen. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab5dca7cb70934c421f7e6fac40543a82a23ccd07d4ab6cc418f7b6f036611521f" name="ab5dca7cb70934c421f7e6fac40543a82a23ccd07d4ab6cc418f7b6f036611521f"></a>SC_IO_MODE_LAST&#160;</td><td class="fielddoc"><p >Invalid entry to close list. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3fce587b8ebade7a4aed4b628236620f" name="a3fce587b8ebade7a4aed4b628236620f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fce587b8ebade7a4aed4b628236620f">&#9670;&nbsp;</a></span>sc_io_open_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620f">sc_io_open_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open modes for <a class="el" href="sc__io_8h.html#aa79491ec78fabf548a23f7cebf3c6f50">sc_io_open</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3fce587b8ebade7a4aed4b628236620faf5747afab45df3d2ef2727fc3cf2c176" name="a3fce587b8ebade7a4aed4b628236620faf5747afab45df3d2ef2727fc3cf2c176"></a>SC_IO_READ&#160;</td><td class="fielddoc"><p >open a file in read-only mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fce587b8ebade7a4aed4b628236620fa35706293af9dc697ce928814db943ec2" name="a3fce587b8ebade7a4aed4b628236620fa35706293af9dc697ce928814db943ec2"></a>SC_IO_WRITE_CREATE&#160;</td><td class="fielddoc"><p >open a file in write-only mode; if the file exists, the file will be truncated to length zero and then overwritten </p>
</td></tr>
<tr><td class="fieldname"><a id="a3fce587b8ebade7a4aed4b628236620fad456fa310244fe36138df7da9c037317" name="a3fce587b8ebade7a4aed4b628236620fad456fa310244fe36138df7da9c037317"></a>SC_IO_WRITE_APPEND&#160;</td><td class="fielddoc"><p >append to an already existing file </p>
</td></tr>
</table>

</div>
</div>
<a id="a4a1276d327fb08fa6e653e75601c3bcc" name="a4a1276d327fb08fa6e653e75601c3bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1276d327fb08fa6e653e75601c3bcc">&#9670;&nbsp;</a></span>sc_io_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcc">sc_io_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of I/O operation <a class="el" href="structsc__io__sink.html">sc_io_sink</a> and <a class="el" href="structsc__io__source.html">sc_io_source</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a1276d327fb08fa6e653e75601c3bcca9f8320af9147bb482644137c23c8b8d7" name="a4a1276d327fb08fa6e653e75601c3bcca9f8320af9147bb482644137c23c8b8d7"></a>SC_IO_TYPE_BUFFER&#160;</td><td class="fielddoc"><p >Write to a buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a1276d327fb08fa6e653e75601c3bcca979ae36e2356c9b5869ef9db91dde818" name="a4a1276d327fb08fa6e653e75601c3bcca979ae36e2356c9b5869ef9db91dde818"></a>SC_IO_TYPE_FILENAME&#160;</td><td class="fielddoc"><p >Write to a file to be opened. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a1276d327fb08fa6e653e75601c3bcca38e65d72498bd27529052aba24c5037b" name="a4a1276d327fb08fa6e653e75601c3bcca38e65d72498bd27529052aba24c5037b"></a>SC_IO_TYPE_FILEFILE&#160;</td><td class="fielddoc"><p >Write to an already opened file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a1276d327fb08fa6e653e75601c3bcca63d8fbfd9109899c05318191ab95ee54" name="a4a1276d327fb08fa6e653e75601c3bcca63d8fbfd9109899c05318191ab95ee54"></a>SC_IO_TYPE_LAST&#160;</td><td class="fielddoc"><p >Invalid entry to close list. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adcac5f2f255041819e5b8b95d03526e7" name="adcac5f2f255041819e5b8b95d03526e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac5f2f255041819e5b8b95d03526e7">&#9670;&nbsp;</a></span>sc_fflush_fsync_fclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_fflush_fsync_fclose </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Best effort to flush a file's data to disc and close it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>File open for writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a928b33f964817cd7a4427a6a23195b1c" name="a928b33f964817cd7a4427a6a23195b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928b33f964817cd7a4427a6a23195b1c">&#9670;&nbsp;</a></span>sc_fopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * sc_fopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for fopen(3). </p>
<p >We provide an additional argument that contains the error message. </p>

</div>
</div>
<a id="ac1a395d6f476dc4e2f06bf5ca9d91689" name="ac1a395d6f476dc4e2f06bf5ca9d91689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a395d6f476dc4e2f06bf5ca9d91689">&#9670;&nbsp;</a></span>sc_fread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_fread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read file content into memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Data array to read from disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of one array member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>File pointer, must be opened for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errmsg</td><td>Error message passed to SC_CHECK_ABORT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts on file errors. </dd></dl>

</div>
</div>
<a id="a3f3a70bcfdb82fb2ff9d7dfeff465dce" name="a3f3a70bcfdb82fb2ff9d7dfeff465dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3a70bcfdb82fb2ff9d7dfeff465dce">&#9670;&nbsp;</a></span>sc_fwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_fwrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write memory content to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to write to disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of one array member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>File pointer, must be opened for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errmsg</td><td>Error message passed to SC_CHECK_ABORT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts on file errors. </dd></dl>

</div>
</div>
<a id="a9ced91d9486b64399a66ccc794a98545" name="a9ced91d9486b64399a66ccc794a98545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ced91d9486b64399a66ccc794a98545">&#9670;&nbsp;</a></span>sc_io_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close collectively a sc_MPI_File. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>MPI file object that is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. </dd></dl>

</div>
</div>
<a id="a99317ed3eb0e67c0c8f907ad1d2f00af" name="a99317ed3eb0e67c0c8f907ad1d2f00af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99317ed3eb0e67c0c8f907ad1d2f00af">&#9670;&nbsp;</a></span>sc_io_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_original_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>re</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a block of base 64 encoded compressed data. </p>
<p >The base 64 data must contain two arbitrary bytes after every 76 code characters and also at the end of the last line if it is short, and then a final NUL character. This function does not require zlib but benefits for speed.</p>
<p >This is a two-stage process: we decode the input from base 64 first. Then we extract the 8-byte big-endian original data size, the character 'z', and execute a zlib decompression on the remaining decoded data. This function detects malformed input by erroring out.</p>
<p >If we should add another format in the future, the format character may be something else than 'z', as permitted by our specification. To this end, we reserve the characters A-C and d-z indefinitely.</p>
<p >Any error condition is indicated by a negative return value. Possible causes for error are:</p>
<ul>
<li>the input data string is not NUL-terminated</li>
<li>the first 12 characters of input do not decode properly</li>
<li>the input data is corrupt for decoding or decompression</li>
<li>the output data array has non-unit element size and the length of the output data is not divisible by the size</li>
<li>the output data would exceed the specified threshold</li>
<li>the output array is a view of insufficient length</li>
</ul>
<p >We also error out if the data requires a compression dictionary, which would be a violation of above encode format specification.</p>
<p >The corresponding encode function is <a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a>. When passing an array as output, we resize it properly. This function cannot crash unless out of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>If <em>out</em> is NULL, we work in place. In that case, output is written into this array after a suitable resize. Either way, we expect a NUL-terminated base 64 encoded string on input that has in turn been obtained by zlib compression. It must be in the exact format produced by <a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a>; please see documentation. The element size of the input array must be 1. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>If not NULL, a valid array (may be a view). If NULL, the input array becomes the output. If the output array is a view and the output data larger than its view size, we error out. We expect commensurable element and data size and resize the output to fit exactly, which restores the original input passed to encoding. An output view array of matching size may be constructed using <a class="el" href="sc__io_8h.html#aa398e72498b16db42b5c73a26089a036">sc_io_decode_info</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_original_size</td><td>If nonzero, this is the maximal data size that we will accept after uncompression. If exceeded, return a negative value. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">re</td><td>Provided for error reporting, presently must be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative on malformed input data or insufficient output space. </dd></dl>

</div>
</div>
<a id="aa398e72498b16db42b5c73a26089a036" name="aa398e72498b16db42b5c73a26089a036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa398e72498b16db42b5c73a26089a036">&#9670;&nbsp;</a></span>sc_io_decode_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_decode_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>original_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>re</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode length and format of original input from encoded data. </p>
<p >We expect at least 12 bytes of the format produced by <a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a>. No matter how much data has been encoded by it, this much is available. We decode the original data size and the character indicating the format.</p>
<p >This function does not require zlib. It works with any well-defined data.</p>
<p >Note that this function is not required before <a class="el" href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">sc_io_decode</a>. Calling this function on any result produced by <a class="el" href="sc__io_8h.html#a98ab4446cc9f9f90cec50e5ed04b9575">sc_io_encode</a> will succeed and report a legal format. This function cannot crash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>This must be an array with element size 1. If it contains less than 12 code bytes we error out. It its first 12 bytes do not base 64 decode to 9 bytes we error out. We generally ignore the remaining data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">original_size</td><td>If not NULL and we do not error out, set to the original size as encoded in the data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">format_char</td><td>If not NULL and we do not error out, the ninth character of decoded data indicating the format. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">re</td><td>Provided for error reporting, presently must be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative value on error. </dd></dl>

</div>
</div>
<a id="a98ab4446cc9f9f90cec50e5ed04b9575" name="a98ab4446cc9f9f90cec50e5ed04b9575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ab4446cc9f9f90cec50e5ed04b9575">&#9670;&nbsp;</a></span>sc_io_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_io_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a block of arbitrary data with the default sc_io format. </p>
<p >The corresponding decoder function is <a class="el" href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">sc_io_decode</a>. This function cannot crash unless out of memory.</p>
<p >Currently this function calls <a class="el" href="sc__io_8h.html#a85ce3e1eb47da5a3200dcc9554ed6ab2">sc_io_encode_zlib</a> with compression level Z_BEST_COMPRESSION (subject to change). Without zlib configured that function works uncompressed.</p>
<p >The encoding method and input data size can be retrieved, optionally, from the encoded data by <a class="el" href="sc__io_8h.html#aa398e72498b16db42b5c73a26089a036">sc_io_decode_info</a>. This function decodes the method as a character, which is 'z' for <a class="el" href="sc__io_8h.html#a85ce3e1eb47da5a3200dcc9554ed6ab2">sc_io_encode_zlib</a>. We reserve the characters A-C, d-z indefinitely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>If <em>out</em> is NULL, we work in place. In this case, the array must on input have an element size of 1 byte, which is preserved. After reading all data from this array, it assumes the identity of the <em>out</em> argument below. Otherwise, this is a read-only argument that may have arbitrary element size. On input, all data in the array is used. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>If not NULL, a valid array of element size 1. It must be resizable (not a view). We resize the array to the output data, which always includes a final terminating zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85ce3e1eb47da5a3200dcc9554ed6ab2" name="a85ce3e1eb47da5a3200dcc9554ed6ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce3e1eb47da5a3200dcc9554ed6ab2">&#9670;&nbsp;</a></span>sc_io_encode_zlib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_io_encode_zlib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zlib_compression_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_break_character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a block of arbitrary data, compressed, into an ASCII string. </p>
<p >This is a two-stage process: zlib compress and then encode to base 64. The output is a NUL-terminated string of printable characters.</p>
<p >We first compress the data into the zlib deflate format (RFC 1951). The compressor must use no preset dictionary (this is the default). If zlib is detected on configuration, we compress with the given level. If zlib is not detected, we write data equivalent to Z_NO_COMPRESSION. The status of zlib detection can be queried at compile time using #ifdef SC_HAVE_ZLIB or at run time using <a class="el" href="sc_8h.html#a13762c105b94355ab4bd34641bb5c5b5">sc_have_zlib</a>. Both types of result are readable by a standard zlib uncompress call.</p>
<p >Secondly, we process the input data size as an 8-byte big-endian number, then the letter 'z', and then the zlib compressed data, concatenated, with a base 64 encoder. We break lines after 76 code characters. Each line break consists of two configurable but arbitrary bytes. The line breaks are considered part of the output data specification. The last line is terminated with the same line break and then a NUL.</p>
<p >This routine can work in place or write to an output array. The corresponding decoder function is <a class="el" href="sc__io_8h.html#a99317ed3eb0e67c0c8f907ad1d2f00af">sc_io_decode</a>. This function cannot crash unless out of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>If <em>out</em> is NULL, we work in place. In this case, the array must on input have an element size of 1 byte, which is preserved. After reading all data from this array, it assumes the identity of the <em>out</em> argument below. Otherwise, this is a read-only argument that may have arbitrary element size. On input, all data in the array is used. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>If not NULL, a valid array of element size 1. It must be resizable (not a view). We resize the array to the output data, which always includes a final terminating zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zlib_compression_level</td><td>Compression level between 0 (no compression) and 9 (best compression). The value -1 indicates some default level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_break_character</td><td>This character is arbitrary and specifies the first of two line break bytes. The second byte is always '<br  />
'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b5d6b9b077707913fc8ebed147f434e" name="a2b5d6b9b077707913fc8ebed147f434e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5d6b9b077707913fc8ebed147f434e">&#9670;&nbsp;</a></span>sc_io_file_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_file_load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a file into a buffer in one call. </p>
<p >This function performs error checking and always returns cleanly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to load. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>On input, an array (not a view) of element size 1 and arbitrary contents. On output and success, the complete file contents. On error, contents are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="ab0a561466b45e9164d802e5c09462a01" name="ab0a561466b45e9164d802e5c09462a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a561466b45e9164d802e5c09462a01">&#9670;&nbsp;</a></span>sc_io_file_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_file_save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a buffer to a file in one call. </p>
<p >This function performs error checking and always returns cleanly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to save. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>An array of element size 1 and arbitrary contents, which are written to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a id="aa79491ec78fabf548a23f7cebf3c6f50" name="aa79491ec78fabf548a23f7cebf3c6f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79491ec78fabf548a23f7cebf3c6f50">&#9670;&nbsp;</a></span>sc_io_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a>&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a3fce587b8ebade7a4aed4b628236620f">sc_io_open_mode_t</a>&#160;</td>
          <td class="paramname"><em>amode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#ab12996c8d5e0684fe6859c81992224ca">sc_MPI_Info</a>&#160;</td>
          <td class="paramname"><em>mpiinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a> *&#160;</td>
          <td class="paramname"><em>mpifile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a MPI file or without MPI a file context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>MPI communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The path to the file that we want to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">amode</td><td>An access mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpiinfo</td><td>The MPI info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mpifile</td><td>The MPI file that is opened. This can be a an actual MPI IO file or an internal file conntext to preserve some IO functionalities without MPI IO and to have working code without MPI at all. This output variable is only filled if the return value of the function is <a class="el" href="sc__mpi_8h.html#af85726c815d1f0ac16948b3c205a1cf8">sc_MPI_SUCCESS</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. If the return value is not <a class="el" href="sc__mpi_8h.html#af85726c815d1f0ac16948b3c205a1cf8">sc_MPI_SUCCESS</a>, <b>mpifile</b> is not filled. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not exactly follow the MPI_File semantic in the sense that it truncates files to the length zero before overwriting them. </dd></dl>

</div>
</div>
<a id="acaac8f61fbf993cb257575379f7e5c76" name="acaac8f61fbf993cb257575379f7e5c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaac8f61fbf993cb257575379f7e5c76">&#9670;&nbsp;</a></span>sc_io_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_io_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read MPI file content into memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Data array to read in from disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zcount</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errmsg</td><td>Error message passed to SC_CHECK_ABORT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts on MPI file and count errors. This function does not use the calling convention and error handling as the other sc_io MPI file functions to ensure backwards compatibility. </dd>
<dd>
This function aborts if MPI I/O is not enabled. </dd></dl>

</div>
</div>
<a id="a3c946193f05156b148e9016aa60a2913" name="a3c946193f05156b148e9016aa60a2913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c946193f05156b148e9016aa60a2913">&#9670;&nbsp;</a></span>sc_io_read_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_read_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ocount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read MPI file content into memory for an explicit offset. </p>
<p >This function does not update the file pointer of the MPI file. Contrary to <a class="el" href="sc__io_8h.html#acaac8f61fbf993cb257575379f7e5c76">sc_io_read</a>, it does not abort on read errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in counts of the type <b>t</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to read from disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ocount</td><td>The number of read elements of type <b>t</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. </dd></dl>

</div>
</div>
<a id="a314f8ea4fd91e10a9ace9d0951175897" name="a314f8ea4fd91e10a9ace9d0951175897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314f8ea4fd91e10a9ace9d0951175897">&#9670;&nbsp;</a></span>sc_io_read_at_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_read_at_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ocount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read MPI file content collectively into memory for an explicit offset. </p>
<p >This function does not update the file pointer of the MPI file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in counts of the type <b>t</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to read from disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ocount</td><td>The number of read elements of type <b>t</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. </dd></dl>

</div>
</div>
<a id="ace22410e0cfe7a0ae9700d82067785fe" name="ace22410e0cfe7a0ae9700d82067785fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace22410e0cfe7a0ae9700d82067785fe">&#9670;&nbsp;</a></span>sc_io_sink_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_sink_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align sink to a byte boundary by writing zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sink</td><td>The sink object to align. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_align</td><td>Byte boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="adfa0eb4519e6a08e80806368af1c5d2f" name="adfa0eb4519e6a08e80806368af1c5d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa0eb4519e6a08e80806368af1c5d2f">&#9670;&nbsp;</a></span>sc_io_sink_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_sink_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush all buffered output data to sink. </p>
<p >This function may return SC_IO_ERROR_AGAIN if another write is required. Currently this may happen if BUFFER requires an integer multiple of bytes. If successful, the updated value of bytes read and written is returned in bytes_in/out, and the sink status is reset as if the sink had just been created. In particular, the bytes counters are reset to zero. The internal state of the sink is not changed otherwise. It is legal to continue writing to the sink hereafter. The sink actions taken depend on its type. BUFFER, FILEFILE: none. FILENAME: call fclose on sink-&gt;file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sink</td><td>The sink object to write to. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_in</td><td>Bytes received since the last new or complete call. May be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_out</td><td>Bytes written since the last new or complete call. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if completed, nonzero on error. </dd></dl>

</div>
</div>
<a id="aa622ecff196b59deacaceb17392b1dae" name="aa622ecff196b59deacaceb17392b1dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa622ecff196b59deacaceb17392b1dae">&#9670;&nbsp;</a></span>sc_io_sink_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_sink_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free data sink. </p>
<p >Calls sc_io_sink_complete and discards the final counts. Errors from complete lead to SC_IO_ERROR_FATAL returned from this function. Call sc_io_sink_complete yourself if bytes_out is of interest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sink</td><td>The sink object to complete and free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a659c6c8ed2b84afa02370d24dfa200ab" name="a659c6c8ed2b84afa02370d24dfa200ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659c6c8ed2b84afa02370d24dfa200ab">&#9670;&nbsp;</a></span>sc_io_sink_destroy_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_sink_destroy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> **&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free data sink and NULL the pointer to it. </p>
<p >Except for the handling of the pointer argument, the behavior is the same as for <a class="el" href="sc__io_8h.html#aa622ecff196b59deacaceb17392b1dae">sc_io_sink_destroy</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sink</td><td>Non-NULL pointer to sink pointer. The sink pointer may be NULL, in which case this function does nothing successfully, or a valid <a class="el" href="structsc__io__sink.html">sc_io_sink</a>, which is passed to <a class="el" href="sc__io_8h.html#aa622ecff196b59deacaceb17392b1dae">sc_io_sink_destroy</a>, and the sink pointer is set to NULL afterwards. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a8e60ffff939bb6d350246f4c97d9f07d" name="a8e60ffff939bb6d350246f4c97d9f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e60ffff939bb6d350246f4c97d9f07d">&#9670;&nbsp;</a></span>sc_io_sink_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> * sc_io_sink_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iomode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioencode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a generic data sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iotype</td><td>Type must be a value from <a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcc">sc_io_type_t</a>. Depending on iotype, varargs must follow: BUFFER: sc_array_t * (existing array). FILENAME: const char * (name of file to open). FILEFILE: FILE * (file open for writing). These buffers are only borrowed by the sink. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iomode</td><td>Mode must be a value from <a class="el" href="sc__io_8h.html#ab5dca7cb70934c421f7e6fac40543a82">sc_io_mode_t</a>. For type FILEFILE, data is always appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ioencode</td><td>Must be a value from <a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315b">sc_io_encode_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated sink, or NULL on error. </dd></dl>

</div>
</div>
<a id="a6162967d2e258b52386566141436fb4f" name="a6162967d2e258b52386566141436fb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6162967d2e258b52386566141436fb4f">&#9670;&nbsp;</a></span>sc_io_sink_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_sink_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#a24e09d62a26d3f849b112f577158a3d1">sc_io_sink_t</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_avail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a sink. </p>
<p >Data may be buffered and sunk in a later call. The internal counters sink-&gt;bytes_in and sink-&gt;bytes_out are updated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sink</td><td>The sink object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data passed into sink must be non-NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_avail</td><td>Number of data bytes passed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="ac80e1d5b0874c1cca7a3fe2129b0f7d9" name="ac80e1d5b0874c1cca7a3fe2129b0f7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80e1d5b0874c1cca7a3fe2129b0f7d9">&#9670;&nbsp;</a></span>sc_io_source_activate_mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_activate_mirror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a buffer that mirrors (i.e., stores) the data that was read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to activate mirror in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a87acd257d6d563918d4289af7376a452" name="a87acd257d6d563918d4289af7376a452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87acd257d6d563918d4289af7376a452">&#9670;&nbsp;</a></span>sc_io_source_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align source to a byte boundary by skipping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to align. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_align</td><td>Byte boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="aef6f7717c1f5432845c38723150aa2b4" name="aef6f7717c1f5432845c38723150aa2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6f7717c1f5432845c38723150aa2b4">&#9670;&nbsp;</a></span>sc_io_source_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether all data buffered from source has been returned by read. </p>
<p >If it returns SC_IO_ERROR_AGAIN, another sc_io_source_read is required. If the call returns no error, the internal counters source-&gt;bytes_in and source-&gt;bytes_out are returned to the caller if requested, and reset to 0. The internal state of the source is not changed otherwise. It is legal to continue reading from the source hereafter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to read from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_in</td><td>If not NULL and true is returned, the total size of the data sourced. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_out</td><td>If not NULL and true is returned, total bytes passed out by source_read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SC_IO_ERROR_AGAIN if buffered data remaining. Otherwise return ERROR_NONE and reset counters. </dd></dl>

</div>
</div>
<a id="aa1848d8a873e2e0369a4d8fe3b1093a1" name="aa1848d8a873e2e0369a4d8fe3b1093a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1848d8a873e2e0369a4d8fe3b1093a1">&#9670;&nbsp;</a></span>sc_io_source_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free data source. </p>
<p >Calls sc_io_source_complete and requires it to return no error. This is to avoid discarding buffered data that has not been passed to read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Nonzero if an error is encountered or is_complete returns one. </dd></dl>

</div>
</div>
<a id="a528524daf7cb8916666ecdc9b1220ee4" name="a528524daf7cb8916666ecdc9b1220ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528524daf7cb8916666ecdc9b1220ee4">&#9670;&nbsp;</a></span>sc_io_source_destroy_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_destroy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> **&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free data source and NULL the pointer to it. </p>
<p >Except for the handling of the pointer argument, the behavior is the same as for <a class="el" href="sc__io_8h.html#aa1848d8a873e2e0369a4d8fe3b1093a1">sc_io_source_destroy</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>Non-NULL pointer to source pointer. The source pointer may be NULL, in which case this function does nothing successfully, or a valid <a class="el" href="structsc__io__source.html">sc_io_source</a>, which is passed to <a class="el" href="sc__io_8h.html#aa1848d8a873e2e0369a4d8fe3b1093a1">sc_io_source_destroy</a>, and the source pointer is set to NULL afterwards. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a9885f1e2093446b086f1a86013fc401d" name="a9885f1e2093446b086f1a86013fc401d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9885f1e2093446b086f1a86013fc401d">&#9670;&nbsp;</a></span>sc_io_source_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> * sc_io_source_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioencode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a generic data source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iotype</td><td>Type must be a value from <a class="el" href="sc__io_8h.html#a4a1276d327fb08fa6e653e75601c3bcc">sc_io_type_t</a>. Depending on iotype, varargs must follow: BUFFER: sc_array_t * (existing array). FILENAME: const char * (name of file to open). FILEFILE: FILE * (file open for reading). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ioencode</td><td>Encoding value from <a class="el" href="sc__io_8h.html#aba4b29f5f9ed6b61e7b5672d3098315b">sc_io_encode_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated source, or NULL on error. </dd></dl>

</div>
</div>
<a id="a50a26974dd167da45407fc0e177c7134" name="a50a26974dd167da45407fc0e177c7134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a26974dd167da45407fc0e177c7134">&#9670;&nbsp;</a></span>sc_io_source_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_avail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a source. </p>
<p >The internal counters source-&gt;bytes_in and source-&gt;bytes_out are updated. Data is read until the data buffer has not enough room anymore, or source becomes empty. It is possible that data already read internally remains in the source object for the next call. Call sc_io_source_complete and check its return value to find out. Returns an error if bytes_out is NULL and less than bytes_avail are read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data buffer for reading from source. If NULL the output data will be ignored and we seek forward in the input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_avail</td><td>Number of bytes available in data buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_out</td><td>If not NULL, byte count read into data buffer. Otherwise, requires to read exactly bytes_avail. If this condition is not met, return an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a428a387778989363d2ab70e12a94fc6a" name="a428a387778989363d2ab70e12a94fc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a387778989363d2ab70e12a94fc6a">&#9670;&nbsp;</a></span>sc_io_source_read_mirror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_source_read_mirror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__io_8h.html#ac28782aa073fff5a2b660b420e4bebbb">sc_io_source_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_avail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from the source's mirror. </p>
<p >Same behaviour as sc_io_source_read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source object to read mirror data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data buffer for reading from source's mirror. If NULL the output data will be thrown away. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_avail</td><td>Number of bytes available in data buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bytes_out</td><td>If not NULL, byte count read into data buffer. Otherwise, requires to read exactly bytes_avail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on error. </dd></dl>

</div>
</div>
<a id="a1cad9d095f810ac5cb1165b4b9818a1d" name="a1cad9d095f810ac5cb1165b4b9818a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cad9d095f810ac5cb1165b4b9818a1d">&#9670;&nbsp;</a></span>sc_io_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_io_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write memory content to an MPI file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to write to disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zcount</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errmsg</td><td>Error message passed to SC_CHECK_ABORT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function aborts on MPI file and count errors. This function does not use the calling convention and error handling as the other sc_io MPI file functions to ensure backwards compatibility. </dd>
<dd>
This function aborts if MPI I/O is not enabled. </dd></dl>

</div>
</div>
<a id="a3c5838a147b381f125172eff9baa34a0" name="a3c5838a147b381f125172eff9baa34a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5838a147b381f125172eff9baa34a0">&#9670;&nbsp;</a></span>sc_io_write_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_write_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ocount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write MPI file content into memory for an explicit offset. </p>
<p >This function does not update the file pointer that is part of mpifile. Contrary to <a class="el" href="sc__io_8h.html#a1cad9d095f810ac5cb1165b4b9818a1d">sc_io_write</a>, it does not abort on read errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in etype, where the etype is given by the type t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to write to disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ocount</td><td>The number of written elements of type <b>t</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. </dd></dl>

</div>
</div>
<a id="a8b871e4d73c09f21285667391d8aa430" name="a8b871e4d73c09f21285667391d8aa430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b871e4d73c09f21285667391d8aa430">&#9670;&nbsp;</a></span>sc_io_write_at_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_io_write_at_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a49e8c800eb5828000e1ec671ef4b1cc6">sc_MPI_File</a>&#160;</td>
          <td class="paramname"><em>mpifile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#ad9a06f87c9a8fa3a3a77627423ea9e18">sc_MPI_Offset</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a34a4ebfb3c1546ae0be1a446de46019f">sc_MPI_Datatype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ocount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write MPI file content collectively into memory for an explicit offset. </p>
<p >This function does not update the file pointer that is part of mpifile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mpifile</td><td>MPI file object opened for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Starting offset in etype, where the etype is given by the type t. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Data array to write to disk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of array members. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The MPI type for each array member. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ocount</td><td>The number of written elements of type <b>t</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sc_MPI_ERR_* as defined in <a class="el" href="sc__mpi_8h.html">sc_mpi.h</a>. The error code can be passed to <a class="el" href="sc__mpi_8h.html#aff1049001d902a25e96984803d474cfe">sc_MPI_Error_string</a>. </dd></dl>

</div>
</div>
<a id="afbfb10dfc461f46c52cd3837ff2e79ac" name="afbfb10dfc461f46c52cd3837ff2e79ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfb10dfc461f46c52cd3837ff2e79ac">&#9670;&nbsp;</a></span>sc_vtk_write_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vtk_write_binary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>vtkfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>numeric_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes numeric binary data in VTK base64 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtkfile</td><td>Stream opened for writing. </td></tr>
    <tr><td class="paramname">numeric_data</td><td>A pointer to a numeric data array. </td></tr>
    <tr><td class="paramname">byte_length</td><td>The length of the data array in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on file error. </dd></dl>

</div>
</div>
<a id="adef98453c04d4b59cb55afc5719c0273" name="adef98453c04d4b59cb55afc5719c0273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef98453c04d4b59cb55afc5719c0273">&#9670;&nbsp;</a></span>sc_vtk_write_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_vtk_write_compressed </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>vtkfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>numeric_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes numeric binary data in VTK compressed format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vtkfile</td><td>Stream opened for writing. </td></tr>
    <tr><td class="paramname">numeric_data</td><td>A pointer to a numeric data array. </td></tr>
    <tr><td class="paramname">byte_length</td><td>The length of the data array in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on file error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
