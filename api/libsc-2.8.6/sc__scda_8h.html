<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsc: src/sc_scda.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libsc<span id="projectnumber">&#160;2.8.6</span>
   </div>
   <div id="projectbrief">The SC library provides support for parallel scientific applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sc_scda.h File Reference<div class="ingroups"><a class="el" href="group__sc.html">The sc Library</a> &raquo; <a class="el" href="group__io.html">I/O</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Routines for parallel I/O with the <b>scda</b> format.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sc__containers_8h_source.html">sc_containers.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sc_scda.h:</div>
<div class="dyncontent">
<div class="center"><img src="sc__scda_8h__incl.png" border="0" usemap="#asrc_2sc__scda_8h" alt=""/></div>
<map name="asrc_2sc__scda_8h" id="asrc_2sc__scda_8h">
<area shape="rect" title="Routines for parallel I/O with the scda format." alt="" coords="281,5,389,32"/>
<area shape="rect" href="sc__containers_8h.html" title="Dynamic containers such as lists, arrays, and hash tables." alt="" coords="274,80,396,107"/>
<area shape="rect" href="sc_8h.html" title="Support for process management (memory allocation, logging, etc.)" alt="" coords="311,155,359,181"/>
<area shape="rect" title=" " alt="" coords="573,379,668,405"/>
<area shape="rect" title=" " alt="" coords="24,229,92,256"/>
<area shape="rect" title=" " alt="" coords="116,229,186,256"/>
<area shape="rect" title=" " alt="" coords="211,229,275,256"/>
<area shape="rect" title=" " alt="" coords="300,229,370,256"/>
<area shape="rect" title=" " alt="" coords="395,229,470,256"/>
<area shape="rect" title=" " alt="" coords="494,229,568,256"/>
<area shape="rect" title=" " alt="" coords="592,229,659,256"/>
<area shape="rect" href="sc__mpi_8h.html" title="Provide a consistent MPI interface with and without MPI configured." alt="" coords="683,229,763,256"/>
<area shape="rect" href="sc3__mpi__types_8h.html" title="We provide MPI replacement data types for configuring without MPI." alt="" coords="658,304,788,331"/>
</map>
</div>
</div>
<p><a href="sc__scda_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__scda__ferror.html">sc_scda_ferror</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error values for the scda functions.  <a href="structsc__scda__ferror.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An options struct for the functions <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> and <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>.  <a href="structsc__scda__fopen__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1c0323b7cb4ddcb91f52714c4b2ba69d"><td class="memItemLeft" align="right" valign="top"><a id="a1c0323b7cb4ddcb91f52714c4b2ba69d" name="a1c0323b7cb4ddcb91f52714c4b2ba69d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SC_SCDA_HEADER_BYTES</b>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:a1c0323b7cb4ddcb91f52714c4b2ba69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of file header bytes <br /></td></tr>
<tr class="separator:a1c0323b7cb4ddcb91f52714c4b2ba69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000763de9ddb4fa54d485df7cfe9378"><td class="memItemLeft" align="right" valign="top"><a id="a2000763de9ddb4fa54d485df7cfe9378" name="a2000763de9ddb4fa54d485df7cfe9378"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SC_SCDA_USER_STRING_BYTES</b>&#160;&#160;&#160;58</td></tr>
<tr class="memdesc:a2000763de9ddb4fa54d485df7cfe9378"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of user string bytes <br /></td></tr>
<tr class="separator:a2000763de9ddb4fa54d485df7cfe9378"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acfad0eccefabd5d5371c69363410bec7"><td class="memItemLeft" align="right" valign="top"><a id="acfad0eccefabd5d5371c69363410bec7" name="acfad0eccefabd5d5371c69363410bec7"></a>
typedef struct sc_scda_fcontext&#160;</td><td class="memItemRight" valign="bottom"><b>sc_scda_fcontext_t</b></td></tr>
<tr class="memdesc:acfad0eccefabd5d5371c69363410bec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque context used for writing a libsc data file. <br /></td></tr>
<tr class="separator:acfad0eccefabd5d5371c69363410bec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4541fe47f55499c0810112f470077793"><td class="memItemLeft" align="right" valign="top"><a id="a4541fe47f55499c0810112f470077793" name="a4541fe47f55499c0810112f470077793"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>sc_scda_ulong</b></td></tr>
<tr class="memdesc:a4541fe47f55499c0810112f470077793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for element counts and sizes. <br /></td></tr>
<tr class="separator:a4541fe47f55499c0810112f470077793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a411e1b7f8f76778d98f154ac360ba5"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">sc_scda_ret</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a6a411e1b7f8f76778d98f154ac360ba5">sc_scda_ret_t</a></td></tr>
<tr class="memdesc:a6a411e1b7f8f76778d98f154ac360ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error values for scda-related errors.  <a href="sc__scda_8h.html#a6a411e1b7f8f76778d98f154ac360ba5">More...</a><br /></td></tr>
<tr class="separator:a6a411e1b7f8f76778d98f154ac360ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3613f101cd3d474bae0609313c45a135"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__scda__ferror.html">sc_scda_ferror</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a></td></tr>
<tr class="memdesc:a3613f101cd3d474bae0609313c45a135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error values for the scda functions.  <a href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">More...</a><br /></td></tr>
<tr class="separator:a3613f101cd3d474bae0609313c45a135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9592038b160f78eea68575505262cb67"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a></td></tr>
<tr class="memdesc:a9592038b160f78eea68575505262cb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">An options struct for the functions <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> and <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>.  <a href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">More...</a><br /></td></tr>
<tr class="separator:a9592038b160f78eea68575505262cb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a859537bb0f5ff43711604b848a8a7477"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">sc_scda_ret</a> { <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a> = 0
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a251d9363925c8f7c46554bbdc030fc49">SC_SCDA_FERR_FORMAT</a> = 15000
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3a6aab8a242abd5288aa51d4419a9320">SC_SCDA_FERR_USAGE</a>
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477acab9f72e1c6008f2f42b9f928f0231ed">SC_SCDA_FERR_DECODE</a>
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a60359488898aea2acd5af677658e74ea">SC_SCDA_FERR_ARG</a>
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a1f9da41f43d91191245e899d1abd14ce">SC_SCDA_FERR_COUNT</a>
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe">SC_SCDA_FERR_MPI</a>
, <br />
&#160;&#160;<a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a00a4fdf04e5ef180cfeb34149fef0935">SC_SCDA_FERR_LASTCODE</a>
<br />
 }</td></tr>
<tr class="memdesc:a859537bb0f5ff43711604b848a8a7477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error values for scda-related errors.  <a href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">More...</a><br /></td></tr>
<tr class="separator:a859537bb0f5ff43711604b848a8a7477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a980fe14b3dec90148e07cc2b21014ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> (<a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a> mpicomm, const char *filename, const char *user_string, size_t *len, <a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a> *opt, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a980fe14b3dec90148e07cc2b21014ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for writing and write the file header to the file.  <a href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">More...</a><br /></td></tr>
<tr class="separator:a980fe14b3dec90148e07cc2b21014ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abc396126346cc792321bc3a9663ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a9abc396126346cc792321bc3a9663ab7">sc_scda_fwrite_inline</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, const char *user_string, size_t *len, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *inline_data, int root, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a9abc396126346cc792321bc3a9663ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an inline data section.  <a href="sc__scda_8h.html#a9abc396126346cc792321bc3a9663ab7">More...</a><br /></td></tr>
<tr class="separator:a9abc396126346cc792321bc3a9663ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd76c5f40c045c0b5f07d9ff533a5668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#afd76c5f40c045c0b5f07d9ff533a5668">sc_scda_fwrite_block</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, const char *user_string, size_t *len, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *block_data, size_t block_size, int root, int encode, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:afd76c5f40c045c0b5f07d9ff533a5668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a fixed-size block file section.  <a href="sc__scda_8h.html#afd76c5f40c045c0b5f07d9ff533a5668">More...</a><br /></td></tr>
<tr class="separator:afd76c5f40c045c0b5f07d9ff533a5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d324691d52269e19b78258c2e085aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a33d324691d52269e19b78258c2e085aa">sc_scda_fwrite_array</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, const char *user_string, size_t *len, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array_data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, size_t elem_size, int indirect, int encode, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a33d324691d52269e19b78258c2e085aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a fixed-size array file section.  <a href="sc__scda_8h.html#a33d324691d52269e19b78258c2e085aa">More...</a><br /></td></tr>
<tr class="separator:a33d324691d52269e19b78258c2e085aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd35e8af3014eaa8ccb83aed9557962"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a5cd35e8af3014eaa8ccb83aed9557962">sc_scda_proc_sizes</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_sizes, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *proc_sizes, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a5cd35e8af3014eaa8ccb83aed9557962"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a collective function to determine the processor sizes.  <a href="sc__scda_8h.html#a5cd35e8af3014eaa8ccb83aed9557962">More...</a><br /></td></tr>
<tr class="separator:a5cd35e8af3014eaa8ccb83aed9557962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad350ac7a692eb1ddedabeaec6045e2ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, const char *user_string, size_t *len, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array_data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_sizes, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *proc_sizes, int indirect, int encode, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:ad350ac7a692eb1ddedabeaec6045e2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a variable-size array file section.  <a href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">More...</a><br /></td></tr>
<tr class="separator:ad350ac7a692eb1ddedabeaec6045e2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae647edc1369b654975acf46e11d1b436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a> (<a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a> mpicomm, const char *filename, char *user_string, size_t *len, <a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a> *opt, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:ae647edc1369b654975acf46e11d1b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file for reading and read the file header from the file.  <a href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">More...</a><br /></td></tr>
<tr class="separator:ae647edc1369b654975acf46e11d1b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ed2776d13337c42bff0b6fc791c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, char *user_string, size_t *len, char *type, size_t *elem_count, size_t *elem_size, int *decode, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:aec0ed2776d13337c42bff0b6fc791c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next file section header.  <a href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">More...</a><br /></td></tr>
<tr class="separator:aec0ed2776d13337c42bff0b6fc791c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0079eb76ffd15ec91140d0813b5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#ae0f0079eb76ffd15ec91140d0813b5bd">sc_scda_fread_inline_data</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *data, int root, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:ae0f0079eb76ffd15ec91140d0813b5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data of an inline data section.  <a href="sc__scda_8h.html#ae0f0079eb76ffd15ec91140d0813b5bd">More...</a><br /></td></tr>
<tr class="separator:ae0f0079eb76ffd15ec91140d0813b5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3e0dcb44c0e922e775287e82a11567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a9d3e0dcb44c0e922e775287e82a11567">sc_scda_fread_block_data</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *block_data, size_t block_size, int root, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a9d3e0dcb44c0e922e775287e82a11567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data of a block of given size.  <a href="sc__scda_8h.html#a9d3e0dcb44c0e922e775287e82a11567">More...</a><br /></td></tr>
<tr class="separator:a9d3e0dcb44c0e922e775287e82a11567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b25eeea7d2532a327c0756d79800f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a258b25eeea7d2532a327c0756d79800f">sc_scda_fread_array_data</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array_data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, size_t elem_size, int indirect, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a258b25eeea7d2532a327c0756d79800f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data of a fixed-size array.  <a href="sc__scda_8h.html#a258b25eeea7d2532a327c0756d79800f">More...</a><br /></td></tr>
<tr class="separator:a258b25eeea7d2532a327c0756d79800f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb9b6c803641aaf581f427fba8e328f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_sizes, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:a5fb9b6c803641aaf581f427fba8e328f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the element sizes of a variable-size array.  <a href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">More...</a><br /></td></tr>
<tr class="separator:a5fb9b6c803641aaf581f427fba8e328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5918cc397b06ae5909ee688f0eddd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#aaa5918cc397b06ae5909ee688f0eddd0">sc_scda_fread_varray_data</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array_data, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_counts, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *elem_sizes, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *proc_sizes, int indirect, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:aaa5918cc397b06ae5909ee688f0eddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data of a variable-size array.  <a href="sc__scda_8h.html#aaa5918cc397b06ae5909ee688f0eddd0">More...</a><br /></td></tr>
<tr class="separator:aaa5918cc397b06ae5909ee688f0eddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01762ce01ec64b560cff9ba9fbf66548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a> (<a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> errcode, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errclass)</td></tr>
<tr class="memdesc:a01762ce01ec64b560cff9ba9fbf66548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a sc_scda error code to an error class.  <a href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">More...</a><br /></td></tr>
<tr class="separator:a01762ce01ec64b560cff9ba9fbf66548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1191840fde06a11537122a5701a75eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> (<a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> errcode, char *str, int *len)</td></tr>
<tr class="memdesc:a1191840fde06a11537122a5701a75eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a sc_scda error code/class to an error string.  <a href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">More...</a><br /></td></tr>
<tr class="separator:a1191840fde06a11537122a5701a75eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad547d1af82bca7b524b39d363fa8a903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__scda_8h.html#ad547d1af82bca7b524b39d363fa8a903">sc_scda_fclose</a> (<a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *fc, <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *errcode)</td></tr>
<tr class="memdesc:ad547d1af82bca7b524b39d363fa8a903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file opened for parallel write/read and the free the file context.  <a href="sc__scda_8h.html#ad547d1af82bca7b524b39d363fa8a903">More...</a><br /></td></tr>
<tr class="separator:ad547d1af82bca7b524b39d363fa8a903"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Routines for parallel I/O with the <b>scda</b> format. </p>
<p >Functionality to write and read in parallel using a prescribed serial-equivalent file format called <b>scda</b>.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
General</h3>
<p >The <b>scda</b> format is as in this <a href="https://doi.org/10.48550/arXiv.2307.06789">preprint</a>.</p>
<p >However, in contrast to the preprint the API in this file provides the two functions <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> and <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a> instead of providing one opening function with a mode parameter to decide and writing and reading.</p>
<p >In addition, we add in this file the options structure <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a> as parameter for opening files.</p>
<p >The file format includes metadata in ASCII and therefore enables the human eye to parse the file structure using a standard text editor.</p>
<p >The file format <b>scda</b> is in particular suitable for parallel I/O and is accompanied by a convention for element-wise compression.</p>
<p >The format is designed such that the the parallel partition and in particular the process count can differ between writing and reading.</p>
<p >The main purpose of <b>scda</b> is to enable the user to implement parallel I/O for numerical appliations, e.g. simulation checkpoint/restart.</p>
<p >We elaborate further on the workflow in <a class="el" href="scda_workflow.html">Parallel I/O workflow</a> .</p>
<h3><a class="anchor" id="autotoc_md1"></a>
User Strings</h3>
<p >The functions</p>
<ul>
<li><a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a>,</li>
<li><a class="el" href="sc__scda_8h.html#a9abc396126346cc792321bc3a9663ab7">sc_scda_fwrite_inline</a>,</li>
<li><a class="el" href="sc__scda_8h.html#afd76c5f40c045c0b5f07d9ff533a5668">sc_scda_fwrite_block</a>,</li>
<li><a class="el" href="sc__scda_8h.html#a33d324691d52269e19b78258c2e085aa">sc_scda_fwrite_array</a>,</li>
<li><a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a>,</li>
<li><a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a> and</li>
<li><a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a></li>
</ul>
<p >have <b>user_string</b> and <b>len</b> as an argument.</p>
<p >The user string consisting of the two parameters <b>user_string</b> and <b>len</b> is always a collective parameter.</p>
<p >In the case of writing these arguments have the purpose to pass the user string that is written to the file.</p>
<p >There are two options writing the user string to the file.</p>
<ol type="1">
<li>A nul-terminated string <b>user_string</b>, i.e. a standard C string. In this case <b>len</b> is set to NULL since the length of <b>user_string</b> is implicitly given by the nul-termination.</li>
<li>Arbitrary data for the user string including possible '\0' in non-terminating positions. We still require nul-termination for safety. One needs to explicitly pass the length, i.e. the number of bytes excluding the nul-termination.</li>
</ol>
<p >For both options it must be respected that the number of maximal <b>user_string</b> bytes is <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 including the nul-termination.</p>
<p >In case of reading <b>user_string</b> must be at least <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes. On output <b>len</b> is set to the number of bytes actually written to <b>user_string</b> excluding the nul-termination.</p>
<p >If it is desired to write arbitrary data without the nul-termination, which is required for the user string, one can write a block data section using the function <a class="el" href="sc__scda_8h.html#afd76c5f40c045c0b5f07d9ff533a5668">sc_scda_fwrite_block</a>.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Encoding</h3>
<p ><b>scda</b> provides optional transparent, element-wise compression of data of file sections. The compression for writing can be enabled by passing true for <b>encode</b> to one of the functions</p>
<ul>
<li><a class="el" href="sc__scda_8h.html#a9abc396126346cc792321bc3a9663ab7">sc_scda_fwrite_inline</a>,</li>
<li><a class="el" href="sc__scda_8h.html#afd76c5f40c045c0b5f07d9ff533a5668">sc_scda_fwrite_block</a>,</li>
<li><a class="el" href="sc__scda_8h.html#a33d324691d52269e19b78258c2e085aa">sc_scda_fwrite_array</a> and</li>
<li><a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a>.</li>
</ul>
<p >The compression on writing can be decided by the user for each file section separately. All parameters on the size of the data written to the file refer to the uncompressed data.</p>
<p >On reading it sufficies to pass <b>decode</b> true to the function <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. Then the file section data is decompressed if it was compressed and otherwise the file section data is read raw. Again all data sizes in reading functions refer to the uncompressed data.</p>
<p >If <b>decode</b> is false, the data is read raw even if it was written according to the compression convention.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Error management</h3>
<p >All <b>scda</b> functions that receive a file context have an output parameter called <b>errcode</b>. In case of an unsuccessful function call, the respective function returns NULL instead of the file context and sets the output parameter <b>errcode</b> to the respective error code. If such a case occurs, the file that is associated to the used file context is closed and the file context is deallocated.</p>
<p >The error code can be examined by the user using the two functions</p><ul>
<li><a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a> and</li>
<li><a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a>.</li>
</ul>
<p >If MPI is available <b>errcode</b> may encode an MPI error code. In this case the two error examination functions output the error class and error string as it would be output by the corresponding MPI functions, respectively. Without MPI it is still possible that <b>errcode</b> encodes an I/O operation related error code. This case does not differ concerning the error code examiniation. Moreover, <b>errcode</b> can encode an error code related to <b>scda</b>, i.e. the I/O operations were successful but there is some violation of the <b>scda</b> format, workflow or API.</p>
<p >For more technical details on <b>errcode</b> see the documentation of <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a>. Furthermore, the <b>scda</b> format, workflow or API errors description can be found in the documentation of <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">sc_scda_ret</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3613f101cd3d474bae0609313c45a135" name="a3613f101cd3d474bae0609313c45a135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3613f101cd3d474bae0609313c45a135">&#9670;&nbsp;</a></span>sc_scda_ferror_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__scda__ferror.html">sc_scda_ferror</a> <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error values for the scda functions. </p>
<p >An error value is a struct since the error can be related to the scda file format or to MPI (I/O operations). The error code can be converted to a string by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> and mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>.</p>
<p >The parsing logic of <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> is that first <b>scdaret</b> is examined and if <b>scdaret</b> != <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe">SC_SCDA_FERR_MPI</a>, we know that <b>mpiret</b> = 0. If <b>scdaret</b> = <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe">SC_SCDA_FERR_MPI</a>, we know that an MPI error occurred and we can examine <b>mpiret</b> for more informartion.</p>
<p >Moreover, a valid <a class="el" href="structsc__scda__ferror.html" title="Error values for the scda functions.">sc_scda_ferror</a> always satisfy that if <b>scdaret</b> = 0 then <b>mpiret</b> = 0 and if <b>scdaret</b> = <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe">SC_SCDA_FERR_MPI</a> then <b>mpiret</b> !=0. </p>

</div>
</div>
<a id="a9592038b160f78eea68575505262cb67" name="a9592038b160f78eea68575505262cb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9592038b160f78eea68575505262cb67">&#9670;&nbsp;</a></span>sc_scda_fopen_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a> <a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An options struct for the functions <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> and <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </p>
<p >The struct may be extended in the future. type for <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a> </p>

</div>
</div>
<a id="a6a411e1b7f8f76778d98f154ac360ba5" name="a6a411e1b7f8f76778d98f154ac360ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a411e1b7f8f76778d98f154ac360ba5">&#9670;&nbsp;</a></span>sc_scda_ret_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">sc_scda_ret</a> <a class="el" href="sc__scda_8h.html#a6a411e1b7f8f76778d98f154ac360ba5">sc_scda_ret_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error values for scda-related errors. </p>
<p >The error codes are part of the struct <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> and can be examined as part of this struct. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a859537bb0f5ff43711604b848a8a7477" name="a859537bb0f5ff43711604b848a8a7477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859537bb0f5ff43711604b848a8a7477">&#9670;&nbsp;</a></span>sc_scda_ret</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477">sc_scda_ret</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error values for scda-related errors. </p>
<p >The error codes are part of the struct <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> and can be examined as part of this struct. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b" name="a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b"></a>SC_SCDA_FERR_SUCCESS&#160;</td><td class="fielddoc"><p >successful function call </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a251d9363925c8f7c46554bbdc030fc49" name="a859537bb0f5ff43711604b848a8a7477a251d9363925c8f7c46554bbdc030fc49"></a>SC_SCDA_FERR_FORMAT&#160;</td><td class="fielddoc"><p >File not conforming to the <b>scda</b> format. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a3a6aab8a242abd5288aa51d4419a9320" name="a859537bb0f5ff43711604b848a8a7477a3a6aab8a242abd5288aa51d4419a9320"></a>SC_SCDA_FERR_USAGE&#160;</td><td class="fielddoc"><p >Incorrect workflow of an <b>scda</b> reading function. </p>
<p >For example, the user might have identified a certain file section type using <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> but then calls a function to read the section data for a different type. Another example is to try reading the data of a 'V' section before reading its element sizes. This error also occurs when the user tries to read section data before reading the section header. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477acab9f72e1c6008f2f42b9f928f0231ed" name="a859537bb0f5ff43711604b848a8a7477acab9f72e1c6008f2f42b9f928f0231ed"></a>SC_SCDA_FERR_DECODE&#160;</td><td class="fielddoc"><p >The decode parameter to <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> is true but the file section header(s) encountered does not conform to the <b>scda</b> encoding convention. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a60359488898aea2acd5af677658e74ea" name="a859537bb0f5ff43711604b848a8a7477a60359488898aea2acd5af677658e74ea"></a>SC_SCDA_FERR_ARG&#160;</td><td class="fielddoc"><p >An argument to a <b>scda</b> file function is invalid. </p>
<p >This occurs for example when an essential pointer argument is NULL or a user string for writing is too long. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a1f9da41f43d91191245e899d1abd14ce" name="a859537bb0f5ff43711604b848a8a7477a1f9da41f43d91191245e899d1abd14ce"></a>SC_SCDA_FERR_COUNT&#160;</td><td class="fielddoc"><p >A byte count error that may occur transiently on writing or the file is short on reading. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe" name="a859537bb0f5ff43711604b848a8a7477ae1b80690aa0c44c868a9bd37ef7bdcbe"></a>SC_SCDA_FERR_MPI&#160;</td><td class="fielddoc"><p >An MPI error occurred; see <b>mpiret</b> in the corresponding <a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a859537bb0f5ff43711604b848a8a7477a00a4fdf04e5ef180cfeb34149fef0935" name="a859537bb0f5ff43711604b848a8a7477a00a4fdf04e5ef180cfeb34149fef0935"></a>SC_SCDA_FERR_LASTCODE&#160;</td><td class="fielddoc"><p >to define own error codes for a higher level application that is using sc_scda functions </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad547d1af82bca7b524b39d363fa8a903" name="ad547d1af82bca7b524b39d363fa8a903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad547d1af82bca7b524b39d363fa8a903">&#9670;&nbsp;</a></span>sc_scda_fclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_scda_fclose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a file opened for parallel write/read and the free the file context. </p>
<p >This is a collective function. Every call of <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> and <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a> must be matched by a corresponding call of <a class="el" href="sc__scda_8h.html#ad547d1af82bca7b524b39d363fa8a903">sc_scda_fclose</a> on the created file context. </p><dl class="section note"><dt>Note</dt><dd>All parameters are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously created by <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a> or <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. This file context is freed after a call of this function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a> for a successful call and -1 in case a of an error. See also <b>errcode</b> argument. </dd></dl>

</div>
</div>
<a id="a01762ce01ec64b560cff9ba9fbf66548" name="a01762ce01ec64b560cff9ba9fbf66548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01762ce01ec64b560cff9ba9fbf66548">&#9670;&nbsp;</a></span>sc_scda_ferror_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_scda_ferror_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a>&#160;</td>
          <td class="paramname"><em>errcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errclass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a sc_scda error code to an error class. </p>
<p >The semantic of error class and error code is the same as in the MPI standard, i.e. all error classes are error codes but potentially there are more error codes than error classes.</p>
<p >If <b>errcode</b> is already an error class, <b>errclass</b> if filled with <b>errcode</b>.</p>
<p >This is a non-collective function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errcode</td><td>An errcode that is output by a sc_scda function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errclass</td><td>On output filled with the error class that corresponds to the given <b>errcode</b>. See the function description above for more information on error classes and error codes in scda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a> on success or something else on invalid arguments. </dd></dl>

</div>
</div>
<a id="a1191840fde06a11537122a5701a75eef" name="a1191840fde06a11537122a5701a75eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1191840fde06a11537122a5701a75eef">&#9670;&nbsp;</a></span>sc_scda_ferror_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_scda_ferror_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a>&#160;</td>
          <td class="paramname"><em>errcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a sc_scda error code/class to an error string. </p>
<p >This is a non-collective function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">errcode</td><td>An errcode that is output by a sc_scda function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>At least sc_MPI_MAX_ERROR_STRING bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>On output the length of string on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a> on success or something else on invalid arguments. </dd></dl>

</div>
</div>
<a id="ae647edc1369b654975acf46e11d1b436" name="ae647edc1369b654975acf46e11d1b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae647edc1369b654975acf46e11d1b436">&#9670;&nbsp;</a></span>sc_scda_fopen_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fopen_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a>&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file for reading and read the file header from the file. </p>
<p >The file must exist and be at least of the size of the file header, i.e. <a class="el" href="sc__scda_8h.html#a1c0323b7cb4ddcb91f52714c4b2ba69d">SC_SCDA_HEADER_BYTES</a> bytes. If the file has a file header that does not satisfy the sc_scda file header format, the function reports the error using SC_LERRORF, collectively close the file and deallocate the file context. In this case the function returns NULL on all ranks. A wrong file header format causes <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a251d9363925c8f7c46554bbdc030fc49">SC_SCDA_FERR_FORMAT</a> as <b>errcode</b>. </p><dl class="section note"><dt>Note</dt><dd>All parameters are collective.</dd></dl>
<p>This function differs from the one opening function for writing and reading introduced in this <b>scda</b> <a href="https://doi.org/10.48550/arXiv.2307.06789">preprint</a>.</p>
<p >This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>The MPI communicator that is used to open the parallel file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to parallel file that is to be created or to be opened. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_string</td><td>At least <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes. <b>user_string</b> is filled with the read user string from file and is nul-terminated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>On output <b>len</b> is set to the number of bytes written to <b>user_string</b> excluding the terminating nul. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>An options structure that provides the possibility to pass further options. See <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a> for more details. It is valid to pass NULL for <b>opt</b>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated context to continue reading and eventually closing the file. NULL in case of error, i.e. errcode != <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a>. </dd></dl>

</div>
</div>
<a id="a980fe14b3dec90148e07cc2b21014ce2" name="a980fe14b3dec90148e07cc2b21014ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980fe14b3dec90148e07cc2b21014ce2">&#9670;&nbsp;</a></span>sc_scda_fopen_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fopen_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__mpi_8h.html#a969bae9e79f582bf2addd41537625ed8">sc_MPI_Comm</a>&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a9592038b160f78eea68575505262cb67">sc_scda_fopen_options_t</a> *&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file for writing and write the file header to the file. </p>
<p >This function creates a new file or overwrites an existing one. It is collective and creates the file on a parallel file system. </p><dl class="section note"><dt>Note</dt><dd>All parameters are collective. This function leaves the file open if MPI is available. Independent of the availability of MPI the user can write one or more file sections before closing the file (context) using <a class="el" href="sc__scda_8h.html#ad547d1af82bca7b524b39d363fa8a903">sc_scda_fclose</a>.</dd></dl>
<p>It is the user's responsibility to write any further metadata of the file that is required by the application. This can be done by writing file sections. However, the user can use <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a> to open a not already opened file and then use <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> and skipping the respective data bytes using the respective read functions sc_scda_fread_*_data to parse the structure of a given file and some metadata that is written by sc_scda.</p>
<p >This function differs from the one opening function for writing and reading introduced in this <b>scda</b> <a href="https://doi.org/10.48550/arXiv.2307.06789">preprint</a>.</p>
<p >This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>The MPI communicator that is used to open the parallel file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to parallel file that is to be created or to be opened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_string</td><td>At most <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes in a nul-terminated string. See the 'User Strings' section in the detailed description of this file for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes in <b>user_string</b> excluding the terminating nul. On NULL as input <b>user_string</b> is expected to be a nul-terminated C string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>An options structure that provides the possibility to pass further options. See <a class="el" href="structsc__scda__fopen__options.html">sc_scda_fopen_options</a> for more details. It is valid to pass NULL for <b>opt</b>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated context to continue writing and eventually closing the file. NULL in case of error, i.e. errcode != <a class="el" href="sc__scda_8h.html#a859537bb0f5ff43711604b848a8a7477a3d890bc6d359d918ae8b1911f842cc3b">SC_SCDA_FERR_SUCCESS</a>. </dd></dl>

</div>
</div>
<a id="a258b25eeea7d2532a327c0756d79800f" name="a258b25eeea7d2532a327c0756d79800f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b25eeea7d2532a327c0756d79800f">&#9670;&nbsp;</a></span>sc_scda_fread_array_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_array_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data of a fixed-size array. </p>
<p >This is a collective function. This function is only valid to call directly after a successful call of <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. This preceding call gives also the required <b>elem_size</b> and the global number of array elements. The user must pass a parallel partition of the array elements by <b>elem_counts</b>. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>array_data</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">array_data</td><td>If <b>indirect</b> is false, a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count equals to the p-th entry of <b>elem_counts</b> for p being the calling rank. The element size must be equal to <b>elem_size</b>. If <b>indirect</b> is true, a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with the same element count as for <b>indirect</b> false but with sizeof (sc_array_t) as element size. Each array element is then again a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> but with element count 1 and element size <b>elem_size</b>. The data can be skipped on each process by locally passing NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count of <b>elem_counts</b> must be the mpisize of the MPI communicator that was used to create <b>fc</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must contain the local array elements counts. That is why it induces the partition that is used to read the array data in parallel. The sum of all array elements must be equal to elem_count as retrieved from <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>The element size of one array element on number of bytes. Must be the same on all ranks and as retrieved from <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>A Boolean to determine whether <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> of sc_arrays to read indirectly and in particular to potentially non-contigous memory. See the documentation of the parameter <b>array_data</b> for more information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="a9d3e0dcb44c0e922e775287e82a11567" name="a9d3e0dcb44c0e922e775287e82a11567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3e0dcb44c0e922e775287e82a11567">&#9670;&nbsp;</a></span>sc_scda_fread_block_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_block_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data of a block of given size. </p>
<p >This is a collective function. This function is only valid to call directly after a successful call of <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. This preceding call gives also the required <b>block_size</b>. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>data_block</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_data</td><td>A <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count 1 and element size <b>block_size</b>. On output the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> is filled with the block data of the read block data section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>The number of bytes of the block as retrieved from the preceding call of <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>An integer between 0 and mpisize exclusive of the MPI communicator that was used to create <b>fc</b>. <b>root</b> indicates the MPI rank on that <b>block_data</b> is read from the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="ae0f0079eb76ffd15ec91140d0813b5bd" name="ae0f0079eb76ffd15ec91140d0813b5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f0079eb76ffd15ec91140d0813b5bd">&#9670;&nbsp;</a></span>sc_scda_fread_inline_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_inline_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data of an inline data section. </p>
<p >This is a collective function. This function is only valid to call directly after a successful call of <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>data</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Exactly 32 bytes on the rank <b>root</b> or NULL on <b>root</b> to not read the bytes. The parameter is ignored on all ranks unequal to <b>root</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>An integer between 0 and mpisize exclusive of the MPI communicator that was used to create <b>fc</b>. <b>root</b> indicates the MPI rank on that <b>data</b> is read from the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="aec0ed2776d13337c42bff0b6fc791c59" name="aec0ed2776d13337c42bff0b6fc791c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0ed2776d13337c42bff0b6fc791c59">&#9670;&nbsp;</a></span>sc_scda_fread_section_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_section_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>elem_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next file section header. </p>
<p >This is a collective function. This functions reads the next file section header and provides the user information on the subsequent file section that can be used to read the actual data in a next calling depending on the file section type one (or for a variable-size array two) functions out of <a class="el" href="sc__scda_8h.html#a9d3e0dcb44c0e922e775287e82a11567">sc_scda_fread_block_data</a>, <a class="el" href="sc__scda_8h.html#a258b25eeea7d2532a327c0756d79800f">sc_scda_fread_array_data</a>, <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a> and <a class="el" href="sc__scda_8h.html#aaa5918cc397b06ae5909ee688f0eddd0">sc_scda_fread_varray_data</a>. </p><dl class="section note"><dt>Note</dt><dd>All parameters are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_string</td><td>At least <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> +1 bytes. <b>user_string</b> is filled with the read user string from file and is nul-terminated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>On output <b>len</b> is set to the number of bytes written to <b>user_string</b> excluding the terminating nul. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>On output this char is set to 'I' (inline data), 'B' (block of given size), 'A' (fixed-size array) or 'V' (variable-size array) depending on the file section type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem_count</td><td>On output set to the global number of array elements if <b>type</b> equals 'A' or 'V'. For 'I' and 'B' as <b>type</b>, <b>elem_count</b> is set 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem_size</td><td>On output set to the byte count of the array elements if <b>type</b> is 'A' and for the <b>type</b> 'B' the number of bytes. Otherwise set to 0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">decode</td><td>On input a Boolean to decide whether the file section shall possibly be interpreted as a compressed section, i.e. they were written by a sc_scda_fwrite_* function with encode set to true. For <b>decode</b> true as input the file section is interpreted as a compressed file section if the type and user string of the first raw file section satisfiy the compression convention. If the compression convention is not satisfied the data is read raw. For false as input the data will be read raw by the subsequent sc_scda_fread_* calls. The output value is always false if the input was set to false. Otherwise, the output is a Boolean that indicates if the nex file section contains a file section type and user string matching the compression convention. The subsequent sc_scda_fread_* calls do not require any adjustment dependent on <b>decode</b>. See also the 'Encoding' section in the detailed description in this file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="aaa5918cc397b06ae5909ee688f0eddd0" name="aaa5918cc397b06ae5909ee688f0eddd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5918cc397b06ae5909ee688f0eddd0">&#9670;&nbsp;</a></span>sc_scda_fread_varray_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_varray_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>proc_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data of a variable-size array. </p>
<p >This is a collective function. This function is only valid to call directly after a successful call of <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a>. This preceding call gives also the required <b>elem_sizes</b>. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>array_data</b> and <b>elem_sizes</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">array_data</td><td>Let p be the calling rank. If <b>indirect</b> is false, <b>array_data</b> must have element count 1 and as element size the p-th entry of <b>proc_sizes</b>. On output the data of the array is set to the local array elements conforming with <b>elem_counts</b>, <b>proc_sizes</b> and <b>elem_sizes</b>. If <b>indirect</b> is true, <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count equal to the p-th array entry of <b>elem_counts</b> and element size equal to sizeof (sc_array_t). Each array element is again a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a>. Now, with element count 1 and element size equals to the actual array element size as passed in <b>elem_sizes</b>. On output these arrays are filled with the actual elements of the read variable-size array. The data can be skipped on each process by locally passing NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count of <b>elem_counts</b> must be the mpisize of the MPI communicator that was used to create <b>fc</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must contain the local array elements counts. That is why it induces the partition that is used to read the array data in parallel. The sum of all array elements must be equal to elem_count as retrieved from <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_sizes</td><td>The local element sizes conforming to the array element partition <b>elem_counts</b> as retrieved from <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a>. This parameter is ignored for ranks to which NULL for <b>array_data</b> was passed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proc_sizes</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count and element size must be the same as for <b>elem_counts</b>. The array must contain the overall byte count per rank conforming with the passed array element partition <b>elem_counts</b> and the local array element sizes in <b>elem_sizes</b>. This parameter can be computed using <a class="el" href="sc__scda_8h.html#a5cd35e8af3014eaa8ccb83aed9557962">sc_scda_proc_sizes</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>A Boolean to determine whether <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> of sc_arrays to read indirectly and in particular to potentially non-contigous memory. See the documentation of the parameter <b>array_data</b> for more information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="a5fb9b6c803641aaf581f427fba8e328f" name="a5fb9b6c803641aaf581f427fba8e328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb9b6c803641aaf581f427fba8e328f">&#9670;&nbsp;</a></span>sc_scda_fread_varray_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fread_varray_sizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the element sizes of a variable-size array. </p>
<p >This is a collective function. This function is only valid to call directly after a successful call of <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. This preceding call gives also the for <b>elem_counts</b> required global number of array elements. The user must pass a parallel partition of the array elements by <b>elem_counts</b>. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>elem_sizes</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#ae647edc1369b654975acf46e11d1b436">sc_scda_fopen_read</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem_sizes</td><td>A <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count equals to p-th entry of <b>elem_counts</b> for p being the calling rank. The element size must be sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). On output the array is filled with the local array element byte counts, where locality is determined by <b>elem_counts</b>. The element sizes can be skipped on each process by locally passing NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count of <b>elem_counts</b> must be the mpisize of the MPI communicator that was used to create <b>fc</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must contain the local array elements counts. That is why it induces the partition that is used to read the array data in parallel. The sum of all array elements must be equal to elem_count as retrieved from <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue reading and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="a33d324691d52269e19b78258c2e085aa" name="a33d324691d52269e19b78258c2e085aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d324691d52269e19b78258c2e085aa">&#9670;&nbsp;</a></span>sc_scda_fwrite_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fwrite_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a fixed-size array file section. </p>
<p >This is a collective function. The fixed-size array is the simplest file section that enables the user to write and read data in parallel. This function writes an array of a given element global count and a fixed element size. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>array_data</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_string</td><td>At most <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes in a nul-terminated string. See the 'User Strings' section in the detailed description of this file for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes in <b>user_string</b> excluding the terminating nul. On NULL as input <b>user_string</b> is expected to be a nul-terminated C string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_data</td><td>On rank p the p-th entry of <b>elem_counts</b> must be the element count of <b>array_data</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to <b>elem_size</b> if <b>indirect</b> is false. Otherwise, <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> of sc_arrays, i.e. a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element size sizeof (sc_array_t). Each of the elements of <b>array_data</b> is then a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count 1 and element size <b>elem_size</b>. See also the documentation of the parameter <b>indirect</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count of <b>elem_counts</b> must be the mpisize of the MPI communicator that was used to create <b>fc</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must contain the local array elements counts (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). That is why it induces the partition that is used to write the array data in parallel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>The element size of one array element on number of bytes. Must be the same on all ranks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>A Boolean to determine whether <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> of sc_arrays to write indirectly and in particular from potentially non-contigous memory. In the remaining case of <b>indirect</b> being false <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element size equals to <b>elem_size</b> that contains the actual array elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encode</td><td>A Boolean to decide whether the file section is written compressed. This results in two written file sections that can be read without the encoding interpretation by using <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> with decode set to false followed by the usual sc_scda_fread functions. The data can be read as passed to this function by using decode true in <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> and calling the usual sc_scda_fread function. See also the 'Encoding' section in the detailed description in this file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue writing and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="afd76c5f40c045c0b5f07d9ff533a5668" name="afd76c5f40c045c0b5f07d9ff533a5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd76c5f40c045c0b5f07d9ff533a5668">&#9670;&nbsp;</a></span>sc_scda_fwrite_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fwrite_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a fixed-size block file section. </p>
<p >This is a collective function. This function writes a data block of fixed size to the file. The <b>block_data</b> is written on the MPI rank <b>root</b>. The number of block bytes must be less or equal 10^{26} - 1. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>block_data</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_string</td><td>At most <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes in a nul-terminated string. See the 'User Strings' section in the detailed description of this file for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes in <b>user_string</b> excluding the terminating nul. On NULL as input <b>user_string</b> is expected to be a nul-terminated C string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_data</td><td>On rank <b>root</b> a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with one element and element size equals to <b>block_size</b>. On all other ranks the parameter is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_size</td><td>The size of the data block in bytes. Must be less or equal than 10^{26} - 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>An integer between 0 and mpisize of the MPI communicator that was used to create <b>fc</b>. <b>root</b> indicates the MPI rank on that <b>block_data</b> is written to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encode</td><td>A Boolean to decide whether the file section is written compressed. This results in two written file sections that can be read without the encoding interpretation by using <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> with decode set to false followed by the usual sc_scda_fread functions. The data can be read as passed to this function by using decode true in <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> and calling the usual sc_scda_fread function. See also the 'Encoding' section in the detailed description in this file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue writing and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="a9abc396126346cc792321bc3a9663ab7" name="a9abc396126346cc792321bc3a9663ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abc396126346cc792321bc3a9663ab7">&#9670;&nbsp;</a></span>sc_scda_fwrite_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fwrite_inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>inline_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an inline data section. </p>
<p >This is a collective function. This function writes 32 bytes of user-defined data preceded by a file section header containing a user string. In contrast to other file sections the inline data section does not end with padded data bytes and therefore require exactly 32 bytes data from the user. This enables the user to implement custom file structuring or padding. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>data</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_string</td><td>At most <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes in a nul-terminated string. See the 'User Strings' section in the detailed description of this file for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes in <b>user_string</b> excluding the terminating nul. On NULL as input <b>user_string</b> is expected to be a nul-terminated C string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inline_data</td><td>On the rank <b>root</b> a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count 1 and element size 32. On all other ranks this parameter is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>An integer between 0 and mpisize exclusive of the MPI communicator that was used to create <b>fc</b>. <b>root</b> indicates the MPI rank on that <b>inline_data</b> is written to the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue writing and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="ad350ac7a692eb1ddedabeaec6045e2ba" name="ad350ac7a692eb1ddedabeaec6045e2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad350ac7a692eb1ddedabeaec6045e2ba">&#9670;&nbsp;</a></span>sc_scda_fwrite_varray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> * sc_scda_fwrite_varray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#acfad0eccefabd5d5371c69363410bec7">sc_scda_fcontext_t</a> *&#160;</td>
          <td class="paramname"><em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>proc_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indirect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>encode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a variable-size array file section. </p>
<p >This is a collective function. This function can be used instead of <a class="el" href="sc__scda_8h.html#a33d324691d52269e19b78258c2e085aa">sc_scda_fwrite_array</a> if the array elements do not have a constant element size in bytes. </p><dl class="section note"><dt>Note</dt><dd>All parameters except of <b>array_data</b> and <b>elem_sizes</b> are collective.</dd></dl>
<p>This function returns NULL on I/O errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fc</td><td>File context previously opened by <a class="el" href="sc__scda_8h.html#a980fe14b3dec90148e07cc2b21014ce2">sc_scda_fopen_write</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_string</td><td>At most <a class="el" href="sc__scda_8h.html#a2000763de9ddb4fa54d485df7cfe9378">SC_SCDA_USER_STRING_BYTES</a> + 1 bytes in a nul-terminated string. See the 'User Strings' section in the detailed description of this file for more information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes in <b>user_string</b> excluding the terminating nul. On NULL as input <b>user_string</b> is expected to be a nul-terminated C string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_data</td><td>Let p be the calling rank. If <b>indirect</b> is false, <b>array_data</b> must have element count 1 and as element size the p-th entry of <b>proc_sizes</b>. The data of the array must be the local array elements conforming with <b>elem_counts</b>, <b>proc_sizes</b> and <b>elem_sizes</b>. If <b>indirect</b> is true, <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element count equal to the p-th array entry of <b>elem_counts</b> and element size equal to sizeof (sc_array_t). Each array element is again a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a>. Now, with element count 1 and element size equals to the actual array element size as passed in <b>elem_sizes</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count of <b>elem_counts</b> must be the mpisize of the MPI communicator that was used to create <b>fc</b>. The element size of the <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must be equal to sizeof (unint8_t). The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> must contain the local array elements counts. That is why it induces the partition that is used to write the array data in parallel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_sizes</td><td>A <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with the element sizes for the local array elements. The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> has an element count of p-th entry of <b>elem_counts</b> for p being the calling rank. The element size is sizeof (<a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proc_sizes</td><td>An <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> that must be equal on all ranks. The element count and element size must be the same as for <b>elem_counts</b>. The array must contain the overall byte count per rank conforming with the passed array element partition <b>elem_counts</b> and the local array element sizes in <b>elem_sizes</b>. This parameter can be computed using <a class="el" href="sc__scda_8h.html#a5cd35e8af3014eaa8ccb83aed9557962">sc_scda_proc_sizes</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indirect</td><td>A Boolean to determine whether <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> of sc_arrays to write indirectly and in particular from potentially non-contigous memory. In the remaining case of <b>indirect</b> being false <b>array_data</b> must be a <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with the actual array elements as data as further explained in the documentation of <b>array_data</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encode</td><td>A Boolean to decide whether the file section is written compressed. This results in two written file sections that can be read without the encoding interpretation by using <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> with decode set to false followed by the usual sc_scda_fread functions. The data can be read as passed to this function by using decode true in <a class="el" href="sc__scda_8h.html#aec0ed2776d13337c42bff0b6fc791c59">sc_scda_fread_section_header</a> and calling the usual sc_scda_fread function. See also the 'Encoding' section in the detailed description in this file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the input context <b>fc</b> on success. The context is used to continue writing and eventually closing the file. In case of any error, attempt to close the file and deallocate the context <b>fc</b>. </dd></dl>

</div>
</div>
<a id="a5cd35e8af3014eaa8ccb83aed9557962" name="a5cd35e8af3014eaa8ccb83aed9557962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd35e8af3014eaa8ccb83aed9557962">&#9670;&nbsp;</a></span>sc_scda_proc_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_scda_proc_sizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>elem_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>proc_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__scda_8h.html#a3613f101cd3d474bae0609313c45a135">sc_scda_ferror_t</a> *&#160;</td>
          <td class="paramname"><em>errcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a collective function to determine the processor sizes. </p>
<p >The purpose of this function is determine the <b>proc_sizes</b> argument as required by <a class="el" href="sc__scda_8h.html#aaa5918cc397b06ae5909ee688f0eddd0">sc_scda_fread_varray_data</a> given the data that can be retrieved by calling <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a> or as required by <a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a> given <b>elem_sizes</b> and <b>elem_counts</b> as passed to <a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a>. </p><dl class="section note"><dt>Note</dt><dd>All parameters are collective.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_sizes</td><td>The <b>elem_sizes</b> array as retrieved by <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a> or passed to <a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_counts</td><td>The <b>elem_counts</b> array as retrieved by <a class="el" href="sc__scda_8h.html#a5fb9b6c803641aaf581f427fba8e328f">sc_scda_fread_varray_sizes</a> or passed to <a class="el" href="sc__scda_8h.html#ad350ac7a692eb1ddedabeaec6045e2ba">sc_scda_fwrite_varray</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">proc_sizes</td><td>A <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> with element size <a class="el" href="sc__scda_8h.html#a4541fe47f55499c0810112f470077793">sc_scda_ulong</a> that is resized on output to the length of <b>elem_sizes</b> and <b>elem_counts</b>. The array is filled with the number bytes per process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errcode</td><td>An errcode that can be interpreted by <a class="el" href="sc__scda_8h.html#a1191840fde06a11537122a5701a75eef">sc_scda_ferror_string</a> or mapped to an error class by <a class="el" href="sc__scda_8h.html#a01762ce01ec64b560cff9ba9fbf66548">sc_scda_ferror_class</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success and -1 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
