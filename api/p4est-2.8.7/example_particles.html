<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>p4est: A particle tracking example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">p4est
   &#160;<span id="projectnumber">2.8.7</span>
   </div>
   <div id="projectbrief">p4est is a software library for parallel adaptive mesh refinement.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">A particle tracking example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We include an example to track particles with a dynamic mesh.</p>
<p>The mesh elements are refined such that the number of particles per element stays limited to a configurable number. While the particles move in space, they also move between elements, which means that they may move between processes. We reassign particles to their holding elements in every time step and then repartition the mesh to maintain load balance, where we transfer the particles to new processes together with the holding elements.</p>
<p>We provide both a 2D version in <a class="el" href="particles_2particles2_8c-example.html">particles/particles2.c</a> and a 3D version in <a class="el" href="particles_2particles3_8c-example.html">particles/particles3.c</a>.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Searching the proper element for each particle</h2>
<p>At any time step, any particle may make an arbitrary move through space. This often moves it out of its original holding element, and we need to find a new one. This new element may be on the same or a remote process. This example is a demo for a scalable procedure to identify it. The method works for arbitrary moves and is <em>not</em> restricted to nearest neighbor elements. In consequence, we do not rely on the <a class="el" href="structp4est__ghost.html">p4est_ghost</a> algorithm but on remote and local recursive searches.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Searching the process responsible for each particle</h3>
<p>We proceed in several stages. First, we determine the process that owns the element that the particle has moved into. We can do this in <a class="el" href="structp4est.html" title="The p4est forest datatype.">p4est</a> <em>without</em> knowing about any local or remote elements, since the shape of the partition boundaries is encoded internally using a minimal scheme. The function to determine the process association is <a class="el" href="p4est__search_8h.html#ac1e3c141fb8e18837819b4b3ab35e4ad">p4est_search_partition</a>. It expects the user to provide a callback to indicate whether a point matches a given search element. This search element is not necessarily one of the mesh, but may be a virtual ancestor of any local or remote element, and is generated temporarily by the search recursion. The callback is informed with the current range of suspected processes as a convenience. The point is dropped if the range becomes empty, and the recursion terminates if the range shrinks to one process.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Transfering particles to their elements</h3>
<p>In this example, if a particle changes process we send it there. Thus every process sends one message per receiver process containing all particles leaving towards it. Since the receivers do not know a priori which processes send to it, we explicitly reverse the communication pattern using the <code>sc_notify</code> functionality of the sc library (see there). Once the notification algorithm returns, we have a list of sender and receiver pairs, which we pass to asynchronous MPI point-to-point communication calls.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Searching the element responsible for each local particle</h3>
<p>Some particles stay on the same process, and those that don't are sent away. Conversely, new particles are received that have left their previous remote process. This means that at this point, every particle is properly assigned to the process. It remains to find the local element that should be holding each one, which we accomplish by calling <a class="el" href="p4est__search_8h.html#a08966f233b715e731217a2c2d288bbeb">p4est_search_local</a>. It expects a callback similar to that of the partition search. The recursion terminates at the proper element for each particle.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Remeshing and particle transfer</h2>
<p>After the particles have moved between elements, most elements will have gained or lost some. We should refine elements with increased particle density and coarsen those where the particles have thinned. To do this, we employ the classic <a class="el" href="structp4est.html" title="The p4est forest datatype.">p4est</a> mesh adaptation mechanism and then retransfer the particles along with the updated partition. Thus, particles move between processes a second time.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Adapting and repartitioning the mesh</h3>
<p>Given the current mesh that was used to time step the particles, we have now redistributed the particles according to their move through space, and possibly transferred them from a different process. The particles have been newly reassigned to the process local elements. We are left with the following challenges:</p>
<ul>
<li>Some elements hold much less or much more particles than desired.</li>
<li>The number of particles per process has become imbalanced.</li>
</ul>
<p>We solve the first issue by adapting the mesh using the functions <a class="el" href="p4est__extended_8h.html#aad32df9df3630b6bac05e7366a5f1e46">p4est_refine_ext</a> and <a class="el" href="p4est__extended_8h.html#a06630b99f70cb85c73452640e8b4d54e">p4est_coarsen_ext</a> non-recursively. Optionally, we call <a class="el" href="p4est__extended_8h.html#a666a197be8d6d83c08cc14bfdc8565ed">p4est_balance_ext</a> to smooth the refinement pattern. These calls produce a mesh within the same partition boundaries, but possibly replacing a parent element with its children or vice versa. Using the <a class="el" href="p4est__extended_8h.html#a3183ffccd96efb695bc0b58ce6010ebd">p4est_replace_t</a> callback, we reassign the particles to the parent or the proper child, respectively, during the adaptation.</p>
<p>To solve the second problem, we <a class="el" href="p4est_8h.html#a808053321e785b3aba01aaa63f68517d">p4est_copy</a> the mesh first and then <a class="el" href="p4est_8h.html#a54c1f4e6bc35c181952371a8046523aa">p4est_partition</a> it using a <a class="el" href="p4est_8h.html#aa03358f1326e23d122ef1b155705fd4d">p4est_weight_t</a> function that takes into account the number of particles per element.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Transfering particles on repartitioning</h3>
<p>We have kept the original refined mesh holding the particles and made a repartitioned mesh that is properly load balanced but still missing the particles. We use the <a class="el" href="p4est__communication_8h.html#ace044f4c221f25afbb9a198ff24b676a">p4est_transfer_custom</a> functionality to message the particles to the new process partition. The element association need not be recomputed, since the global refinement structure is left unchanged by repartitioning. At this point, we delete the old mesh and are ready for the next time step. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
