<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>p4est: src/p6est_extended.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">p4est
   &#160;<span id="projectnumber">2.8.7</span>
   </div>
   <div id="projectbrief">p4est is a software library for parallel adaptive mesh refinement.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">p6est_extended.h File Reference<div class="ingroups"><a class="el" href="group__p6est.html">p6est</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface routines with extended capabilities.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="p6est_8h_source.html">p6est.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for p6est_extended.h:</div>
<div class="dyncontent">
<div class="center"><img src="p6est__extended_8h__incl.png" border="0" usemap="#asrc_2p6est__extended_8h" alt=""/></div>
<map name="asrc_2p6est__extended_8h" id="asrc_2p6est__extended_8h">
<area shape="rect" title="Interface routines with extended capabilities." alt="" coords="90,5,251,32"/>
<area shape="rect" href="p6est_8h.html" title="A hybrid 2D+1D AMR extension." alt="" coords="135,80,206,107"/>
<area shape="rect" href="p4est_8h.html" title="The top&#45;level 2D p4est interface." alt="" coords="99,155,170,181"/>
<area shape="rect" href="p8est__connectivity_8h.html" title="The connectivity defines the coarse topology of the forest." alt="" coords="184,229,339,256"/>
<area shape="rect" href="p4est__connectivity_8h.html" title="The connectivity defines the coarse topology of the forest." alt="" coords="5,229,160,256"/>
<area shape="rect" title=" " alt="" coords="83,304,149,331"/>
<area shape="rect" href="p4est__base_8h.html" title="General support types and functions." alt="" coords="190,304,298,331"/>
<area shape="rect" title=" " alt="" coords="55,379,172,405"/>
<area shape="rect" title=" " alt="" coords="197,379,291,405"/>
<area shape="rect" title=" " alt="" coords="316,379,439,405"/>
</map>
</div>
</div>
<p><a href="p6est__extended_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae022cb93db16a43b57bcb59fe4137612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#ae022cb93db16a43b57bcb59fe4137612">p6est_new_ext</a> (sc_MPI_Comm mpicomm, <a class="el" href="p6est_8h.html#a1333b58e1c0a1c9442c411df39433ee9">p6est_connectivity_t</a> *connectivity, <a class="el" href="p4est__base_8h.html#a9f350ee78755ec6e7d25fb1dca474573">p4est_locidx_t</a> min_quadrants, int min_level, int min_zlevel, int num_zroot, int fill_uniform, size_t data_size, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, void *user_pointer)</td></tr>
<tr class="memdesc:ae022cb93db16a43b57bcb59fe4137612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new forest.  <a href="p6est__extended_8h.html#ae022cb93db16a43b57bcb59fe4137612">More...</a><br /></td></tr>
<tr class="separator:ae022cb93db16a43b57bcb59fe4137612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7851a73258e69f60824c85988560b780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a7851a73258e69f60824c85988560b780">p6est_copy_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *input, int copy_data, int duplicate_mpicomm)</td></tr>
<tr class="memdesc:a7851a73258e69f60824c85988560b780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a deep copy of a <a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a>.  <a href="p6est__extended_8h.html#a7851a73258e69f60824c85988560b780">More...</a><br /></td></tr>
<tr class="separator:a7851a73258e69f60824c85988560b780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4046b82845230652c536f1d416db6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#ac4046b82845230652c536f1d416db6d5">p6est_save_ext</a> (const char *filename, <a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int save_data, int save_partition)</td></tr>
<tr class="memdesc:ac4046b82845230652c536f1d416db6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the complete connectivity/p6est data to disk.  <a href="p6est__extended_8h.html#ac4046b82845230652c536f1d416db6d5">More...</a><br /></td></tr>
<tr class="separator:ac4046b82845230652c536f1d416db6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f25d6467f8b8fa157a1de974c73441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a94f25d6467f8b8fa157a1de974c73441">p6est_load_ext</a> (const char *filename, sc_MPI_Comm mpicomm, size_t data_size, int load_data, int autopartition, int broadcasthead, void *user_pointer, <a class="el" href="p6est_8h.html#a1333b58e1c0a1c9442c411df39433ee9">p6est_connectivity_t</a> **connectivity)</td></tr>
<tr class="memdesc:a94f25d6467f8b8fa157a1de974c73441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the complete connectivity/p6est structure from disk.  <a href="p6est__extended_8h.html#a94f25d6467f8b8fa157a1de974c73441">More...</a><br /></td></tr>
<tr class="separator:a94f25d6467f8b8fa157a1de974c73441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9935bffc09f7357934b5f76fa4ca6b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a9935bffc09f7357934b5f76fa4ca6b79">p6est_refine_columns_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int refine_recursive, int maxlevel, <a class="el" href="p6est_8h.html#a01da15b2c958ea2aa36920fef7e662bc">p6est_refine_column_t</a> refine_fn, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, <a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:a9935bffc09f7357934b5f76fa4ca6b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally refine a forest with a bounded refinement level and a replace option.  <a href="p6est__extended_8h.html#a9935bffc09f7357934b5f76fa4ca6b79">More...</a><br /></td></tr>
<tr class="separator:a9935bffc09f7357934b5f76fa4ca6b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421ee97cf7abe1178dff37305e40b41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a8421ee97cf7abe1178dff37305e40b41">p6est_refine_layers_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int refine_recursive, int maxlevel, <a class="el" href="p6est_8h.html#ad4285b61490aa5dd8b5e88f5d1af3273">p6est_refine_layer_t</a> refine_fn, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, <a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:a8421ee97cf7abe1178dff37305e40b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertically refine a forest with a bounded refinement level and a replace option.  <a href="p6est__extended_8h.html#a8421ee97cf7abe1178dff37305e40b41">More...</a><br /></td></tr>
<tr class="separator:a8421ee97cf7abe1178dff37305e40b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487cb68cd5434aa11e1061c518151e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#ad487cb68cd5434aa11e1061c518151e0">p6est_coarsen_columns_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int coarsen_recursive, int callback_orphans, <a class="el" href="p6est_8h.html#aab3f66cd891e286b29d3bc07662e6432">p6est_coarsen_column_t</a> coarsen_fn, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, <a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:ad487cb68cd5434aa11e1061c518151e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally coarsen a forest.  <a href="p6est__extended_8h.html#ad487cb68cd5434aa11e1061c518151e0">More...</a><br /></td></tr>
<tr class="separator:ad487cb68cd5434aa11e1061c518151e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa032a085da28bacca2aa812f8c788ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#aa032a085da28bacca2aa812f8c788ef5">p6est_coarsen_layers_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int coarsen_recursive, int callback_orphans, <a class="el" href="p6est_8h.html#ada2bb7deed24dc6dde7d1e834d33f80c">p6est_coarsen_layer_t</a> coarsen_fn, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, <a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:aa032a085da28bacca2aa812f8c788ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertically coarsen a forest.  <a href="p6est__extended_8h.html#aa032a085da28bacca2aa812f8c788ef5">More...</a><br /></td></tr>
<tr class="separator:aa032a085da28bacca2aa812f8c788ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3366b7ad13c135d0f6c9c7bed8115d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="p4est__base_8h.html#af4d787f9b2520af0cfe9a10b89235749">p4est_gloidx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a3c3366b7ad13c135d0f6c9c7bed8115d">p6est_partition_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, int partition_for_coarsening, <a class="el" href="p6est_8h.html#a9e899c9ff58121ef87bcfd73e36e2249">p6est_weight_t</a> weight_fn)</td></tr>
<tr class="memdesc:a3c3366b7ad13c135d0f6c9c7bed8115d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the forest.  <a href="p6est__extended_8h.html#a3c3366b7ad13c135d0f6c9c7bed8115d">More...</a><br /></td></tr>
<tr class="separator:a3c3366b7ad13c135d0f6c9c7bed8115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bccbb068c25482f68d01b470dcf941b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="p6est__extended_8h.html#a8bccbb068c25482f68d01b470dcf941b">p6est_balance_ext</a> (<a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *<a class="el" href="structp6est.html">p6est</a>, <a class="el" href="p8est__connectivity_8h.html#aaa5a9d47d1b169507e1095783ab89be1">p8est_connect_type_t</a> btype, int max_diff, int min_diff, <a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a> init_fn, <a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a> replace_fn)</td></tr>
<tr class="memdesc:a8bccbb068c25482f68d01b470dcf941b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2:1 balance the size differences of neighboring elements in a forest.  <a href="p6est__extended_8h.html#a8bccbb068c25482f68d01b470dcf941b">More...</a><br /></td></tr>
<tr class="separator:a8bccbb068c25482f68d01b470dcf941b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface routines with extended capabilities. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8bccbb068c25482f68d01b470dcf941b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bccbb068c25482f68d01b470dcf941b">&#9670;&nbsp;</a></span>p6est_balance_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_balance_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p8est__connectivity_8h.html#aaa5a9d47d1b169507e1095783ab89be1">p8est_connect_type_t</a>&#160;</td>
          <td class="paramname"><em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2:1 balance the size differences of neighboring elements in a forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The <a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a> to be worked on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">btype</td><td>Balance type (face or corner/full). Corner balance is almost never required when discretizing a PDE; just causes smoother mesh grading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_diff</td><td>The maximum difference between the horizontal refinement level and the vertical refinement level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_diff</td><td>The minimum difference between the horizontal refinement level and the vertical refinement level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data which is already allocated automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad487cb68cd5434aa11e1061c518151e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad487cb68cd5434aa11e1061c518151e0">&#9670;&nbsp;</a></span>p6est_coarsen_columns_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_coarsen_columns_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarsen_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callback_orphans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aab3f66cd891e286b29d3bc07662e6432">p6est_coarsen_column_t</a>&#160;</td>
          <td class="paramname"><em>coarsen_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Horizontally coarsen a forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_recursive</td><td>Boolean to decide on recursive coarsening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_orphans</td><td>Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_fn</td><td>Callback function that returns true if a family of quadrants shall be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data which is already allocated automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa032a085da28bacca2aa812f8c788ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa032a085da28bacca2aa812f8c788ef5">&#9670;&nbsp;</a></span>p6est_coarsen_layers_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_coarsen_layers_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coarsen_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callback_orphans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#ada2bb7deed24dc6dde7d1e834d33f80c">p6est_coarsen_layer_t</a>&#160;</td>
          <td class="paramname"><em>coarsen_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertically coarsen a forest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_recursive</td><td>Boolean to decide on recursive coarsening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_orphans</td><td>Boolean to enable calling coarsen_fn even on non-families. In this case, the second quadrant pointer in the argument list of the callback is NULL, subsequent pointers are undefined, and the return value is ignored. If coarsen_recursive is true, it is possible that a quadrant is called once or more as an orphan and eventually becomes part of a family. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsen_fn</td><td>Callback function that returns true if a family of quadrants shall be coarsened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data which is already allocated automatically. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7851a73258e69f60824c85988560b780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7851a73258e69f60824c85988560b780">&#9670;&nbsp;</a></span>p6est_copy_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a>* p6est_copy_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duplicate_mpicomm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a deep copy of a <a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a>. </p>
<p>The connectivity is not duplicated. Copying of quadrant user data is optional. If old and new data sizes are 0, the user_data field is copied regardless. The inspect member of the copy is set to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy_data</td><td>If true, data are copied. If false, data_size is set to 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duplicate_mpicomm</td><td>If true, MPI communicator is copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a valid <a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a> that does not depend on the input. </dd></dl>

</div>
</div>
<a id="a94f25d6467f8b8fa157a1de974c73441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f25d6467f8b8fa157a1de974c73441">&#9670;&nbsp;</a></span>p6est_load_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a>* p6est_load_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>load_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>autopartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>broadcasthead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a1333b58e1c0a1c9442c411df39433ee9">p6est_connectivity_t</a> **&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the complete connectivity/p6est structure from disk. </p>
<p>It is possible to load the file with a different number of processors than has been used to write it. The partition will then be uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>A valid MPI communicator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data for each quadrant which can be zero. Then user_data_pool is set to NULL. If data_size is zero, load_data is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_data</td><td>If true, the element data is loaded. This is only permitted if the saved data size matches. If false, the stored data size is ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autopartition</td><td>Ignore saved partition and make it uniform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">broadcasthead</td><td>Have only rank 0 read headers and bcast them. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_pointer</td><td>Assign to the user_pointer member of the <a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a> before init_fn is called the first time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connectivity</td><td>Connectivity must be destroyed separately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a valid forest structure. A pointer to a valid connectivity structure is returned through the last argument. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Aborts on file errors or invalid file contents. </dd></dl>

</div>
</div>
<a id="ae022cb93db16a43b57bcb59fe4137612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae022cb93db16a43b57bcb59fe4137612">&#9670;&nbsp;</a></span>p6est_new_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a>* p6est_new_ext </td>
          <td>(</td>
          <td class="paramtype">sc_MPI_Comm&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a1333b58e1c0a1c9442c411df39433ee9">p6est_connectivity_t</a> *&#160;</td>
          <td class="paramname"><em>connectivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p4est__base_8h.html#a9f350ee78755ec6e7d25fb1dca474573">p4est_locidx_t</a>&#160;</td>
          <td class="paramname"><em>min_quadrants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_zlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_zroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill_uniform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new forest. </p>
<p>This is a more general form of <a class="el" href="p6est_8h.html#ab60d9c6db36bd6e9358934af4fad5402" title="Create a new forest.">p6est_new()</a>. See the documentation of <a class="el" href="p6est_8h.html#ab60d9c6db36bd6e9358934af4fad5402" title="Create a new forest.">p6est_new()</a> for basic usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>Used und remembered in the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connectivity</td><td>Valid connectivity of tree topologies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_quadrants</td><td>Minimum initial quadrants per processor. Makes the refinement pattern mpisize-specific. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_level</td><td>The forest is horizontally refined at least to this level. May be negative or 0, then it has no effect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_zlevel</td><td>The forest is vertically refined at least to this level. May be negative or 0, then it has no effect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_zroot</td><td>The number of "root" vertical layers (used when non-power-of-2 layers are desired) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_uniform</td><td>If true, fill the forest with a uniform mesh instead of the coarsest possible one. The latter is partition-specific so that is usually not a good idea. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of per-quadrant stored user data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>If not NULL, called on every quadrant created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_pointer</td><td>Stored as is in the result for later reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid forest structure. </dd></dl>

</div>
</div>
<a id="a3c3366b7ad13c135d0f6c9c7bed8115d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3366b7ad13c135d0f6c9c7bed8115d">&#9670;&nbsp;</a></span>p6est_partition_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="p4est__base_8h.html#af4d787f9b2520af0cfe9a10b89235749">p4est_gloidx_t</a> p6est_partition_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partition_for_coarsening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a9e899c9ff58121ef87bcfd73e36e2249">p6est_weight_t</a>&#160;</td>
          <td class="paramname"><em>weight_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repartition the forest. </p>
<p>The forest is partitioned between processors such that each processor has an approximately equal number of quadrants (or weight).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The forest that will be partitioned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">partition_for_coarsening</td><td>If true, the partition is modified to allow one level of coarsening. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_fn</td><td>A weighting function or NULL for uniform partitioning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global number of shipped quadrants </dd></dl>

</div>
</div>
<a id="a9935bffc09f7357934b5f76fa4ca6b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9935bffc09f7357934b5f76fa4ca6b79">&#9670;&nbsp;</a></span>p6est_refine_columns_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_refine_columns_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01da15b2c958ea2aa36920fef7e662bc">p6est_refine_column_t</a>&#160;</td>
          <td class="paramname"><em>refine_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Horizontally refine a forest with a bounded refinement level and a replace option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_recursive</td><td>Boolean to decide on recursive refinement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxlevel</td><td>Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in <a class="el" href="p4est_8h.html" title="The top-level 2D p4est interface.">p4est.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_fn</td><td>Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8421ee97cf7abe1178dff37305e40b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8421ee97cf7abe1178dff37305e40b41">&#9670;&nbsp;</a></span>p6est_refine_layers_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_refine_layers_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refine_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#ad4285b61490aa5dd8b5e88f5d1af3273">p6est_refine_layer_t</a>&#160;</td>
          <td class="paramname"><em>refine_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a01eb07a19337b55978d3e52dfc55dc10">p6est_init_t</a>&#160;</td>
          <td class="paramname"><em>init_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#aacd867e54e2427b196b9948d8d4ed7c9">p6est_replace_t</a>&#160;</td>
          <td class="paramname"><em>replace_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertically refine a forest with a bounded refinement level and a replace option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>The forest is changed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_recursive</td><td>Boolean to decide on recursive refinement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxlevel</td><td>Maximum allowed refinement level (inclusive). If this is negative the level is restricted only by the compile-time constant QMAXLEVEL in <a class="el" href="p4est_8h.html" title="The top-level 2D p4est interface.">p4est.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refine_fn</td><td>Callback function that must return true if a quadrant shall be refined. If refine_recursive is true, refine_fn is called for every existing and newly created quadrant. Otherwise, it is called for every existing quadrant. It is possible that a refinement request made by the callback is ignored. To catch this case, you can examine whether init_fn or replace_fn gets called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_fn</td><td>Callback function to initialize the user_data for newly created quadrants, which is guaranteed to be allocated. This function pointer may be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_fn</td><td>Callback function that allows the user to change incoming quadrants based on the quadrants they replace; may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4046b82845230652c536f1d416db6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4046b82845230652c536f1d416db6d5">&#9670;&nbsp;</a></span>p6est_save_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void p6est_save_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="p6est_8h.html#a283f575657cdccd543fa9fd09f8a7cba">p6est_t</a> *&#160;</td>
          <td class="paramname"><em>p6est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>save_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>save_partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the complete connectivity/p6est data to disk. </p>
<p>This is a collective operation that all MPI processes need to call. All processes write into the same file, so the filename given needs to be identical over all parallel invocations. See <a class="el" href="p6est__extended_8h.html#a94f25d6467f8b8fa157a1de974c73441" title="Load the complete connectivity/p6est structure from disk.">p6est_load_ext()</a> for information on the autopartition parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structp6est.html" title="The p6est forest datatype.">p6est</a></td><td>Valid forest structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_data</td><td>If true, the element data is saved. Otherwise, a data size of 0 is saved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_partition</td><td>If false, save file as if 1 core was used. If true, save core count and partition. Advantage: Partition can be recovered on loading with same mpisize and autopartition false. Disadvantage: Makes the file depend on mpisize. Either way the file can be loaded with autopartition true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Aborts on file errors. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
