<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsc: src/sc_containers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsc
   &#160;<span id="projectnumber">2.8.7</span>
   </div>
   <div id="projectbrief">The SC library provides support for parallel scientific applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sc_containers.h File Reference<div class="ingroups"><a class="el" href="group__sc.html">The sc Library</a> &raquo; <a class="el" href="group__sc__containers.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Dynamic containers such as lists, arrays, and hash tables.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sc_8h_source.html">sc.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sc_containers.h:</div>
<div class="dyncontent">
<div class="center"><img src="sc__containers_8h__incl.png" border="0" usemap="#asrc_2sc__containers_8h" alt=""/></div>
<map name="asrc_2sc__containers_8h" id="asrc_2sc__containers_8h">
<area shape="rect" title="Dynamic containers such as lists, arrays, and hash tables." alt="" coords="262,5,408,32"/>
<area shape="rect" href="sc_8h.html" title="Support for process management (memory allocation, logging, etc.)" alt="" coords="311,80,359,107"/>
<area shape="rect" title=" " alt="" coords="573,304,668,331"/>
<area shape="rect" title=" " alt="" coords="24,155,92,181"/>
<area shape="rect" title=" " alt="" coords="116,155,186,181"/>
<area shape="rect" title=" " alt="" coords="211,155,275,181"/>
<area shape="rect" title=" " alt="" coords="300,155,370,181"/>
<area shape="rect" title=" " alt="" coords="395,155,470,181"/>
<area shape="rect" title=" " alt="" coords="494,155,568,181"/>
<area shape="rect" title=" " alt="" coords="592,155,659,181"/>
<area shape="rect" href="sc__mpi_8h.html" title="Provide a consistent MPI interface with and without MPI configured." alt="" coords="683,155,763,181"/>
<area shape="rect" href="sc3__mpi__types_8h.html" title="We provide MPI replacement data types for configuring without MPI." alt="" coords="658,229,788,256"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sc__containers_8h__dep__incl.png" border="0" usemap="#asrc_2sc__containers_8hdep" alt=""/></div>
<map name="asrc_2sc__containers_8hdep" id="asrc_2sc__containers_8hdep">
<area shape="rect" title="Dynamic containers such as lists, arrays, and hash tables." alt="" coords="189,5,336,32"/>
<area shape="rect" href="sc__io_8h.html" title="Helper routines for general and parallel I/O." alt="" coords="5,80,96,107"/>
<area shape="rect" href="sc__keyvalue_8h.html" title="This file provides a lookup structure for key&#45;value pairs." alt="" coords="121,80,258,107"/>
<area shape="rect" href="sc__scda_8h.html" title="Routines for parallel I/O with the scda format." alt="" coords="282,80,390,107"/>
<area shape="rect" href="sc__unique__counter_8h_source.html" title=" " alt="" coords="415,80,593,107"/>
<area shape="rect" href="sc__options_8h.html" title="Register and parse command line options and read/write configuration files." alt="" coords="47,155,174,181"/>
<area shape="rect" href="sc__statistics_8h.html" title="Computation of average and mean values etc." alt="" coords="198,155,335,181"/>
<area shape="rect" href="sc__amr_8h_source.html" title=" " alt="" coords="148,229,252,256"/>
<area shape="rect" href="sc__notify_8h.html" title="We provide various algorithms to invert the communication pattern." alt="" coords="276,229,391,256"/>
</map>
</div>
</div>
<p><a href="sc__containers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__array.html">sc_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> object provides a dynamic array of equal-size elements.  <a href="structsc__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__mstamp.html">sc_mstamp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data container to create memory items of the same size.  <a href="structsc__mstamp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__mempool.html">sc_mempool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__mempool.html" title="The sc_mempool object provides a large pool of equal-size elements.">sc_mempool</a> object provides a large pool of equal-size elements.  <a href="structsc__mempool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__link.html">sc_link</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__link.html" title="The sc_link structure is one link of a linked list.">sc_link</a> structure is one link of a linked list.  <a href="structsc__link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__list.html">sc_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__list.html" title="The sc_list object provides a linked list.">sc_list</a> object provides a linked list.  <a href="structsc__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__hash.html">sc_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__hash.html" title="The sc_hash implements a hash table.">sc_hash</a> implements a hash table.  <a href="structsc__hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__hash__array.html">sc_hash_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__hash__array.html" title="The sc_hash_array implements an array backed up by a hash table.">sc_hash_array</a> implements an array backed up by a hash table.  <a href="structsc__hash__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsc__recycle__array.html">sc_recycle_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__recycle__array.html" title="The sc_recycle_array object provides an array of slots that can be reused.">sc_recycle_array</a> object provides an array of slots that can be reused.  <a href="structsc__recycle__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab07c2062a328d6072fa398dcf34df750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(x,  k)&#160;&#160;&#160;(((x) &lt;&lt; (k)) | ((x) &gt;&gt; (32 - (k))))</td></tr>
<tr class="memdesc:ab07c2062a328d6072fa398dcf34df750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bijective bit rotation as building block for hash functions.  <a href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">More...</a><br /></td></tr>
<tr class="separator:ab07c2062a328d6072fa398dcf34df750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b111eda1aeb1c0c756c59d001a07caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9b111eda1aeb1c0c756c59d001a07caa">sc_hash_mix</a>(a,  b,  c)</td></tr>
<tr class="memdesc:a9b111eda1aeb1c0c756c59d001a07caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer bit mixer as building block for hash functions.  <a href="sc__containers_8h.html#a9b111eda1aeb1c0c756c59d001a07caa">More...</a><br /></td></tr>
<tr class="separator:a9b111eda1aeb1c0c756c59d001a07caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fd16d6e7d37a678e3e764f68893541"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a15fd16d6e7d37a678e3e764f68893541">sc_hash_final</a>(a,  b,  c)</td></tr>
<tr class="memdesc:a15fd16d6e7d37a678e3e764f68893541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer bit operations as building block for hash functions.  <a href="sc__containers_8h.html#a15fd16d6e7d37a678e3e764f68893541">More...</a><br /></td></tr>
<tr class="separator:a15fd16d6e7d37a678e3e764f68893541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="memItemLeft" align="right" valign="top"><a id="ad9e37c27d608aabb0db95b28ccc27a8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a>(a)&#160;&#160;&#160;((a)-&gt;byte_alloc &gt;= 0)</td></tr>
<tr class="memdesc:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the sc_array_t owns its <em>array</em>. <br /></td></tr>
<tr class="separator:ad9e37c27d608aabb0db95b28ccc27a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94de2c6227fdb03f497aa2524257003"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ae94de2c6227fdb03f497aa2524257003">SC_ARRAY_BYTE_ALLOC</a>(a)</td></tr>
<tr class="memdesc:ae94de2c6227fdb03f497aa2524257003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the allocated size of the array.  <a href="sc__containers_8h.html#ae94de2c6227fdb03f497aa2524257003">More...</a><br /></td></tr>
<tr class="separator:ae94de2c6227fdb03f497aa2524257003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb7566369027bc94437c6973469c8c"><td class="memItemLeft" align="right" valign="top"><a id="a1dfb7566369027bc94437c6973469c8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a1dfb7566369027bc94437c6973469c8c">sc_array_new_size</a>(s,  c)&#160;&#160;&#160;(<a class="el" href="sc__containers_8h.html#a995cca28e6413132e14691834e279504">sc_array_new_count</a> ((s), (c)))</td></tr>
<tr class="memdesc:a1dfb7566369027bc94437c6973469c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated: use <a class="el" href="sc__containers_8h.html#a995cca28e6413132e14691834e279504">sc_array_new_count</a>. <br /></td></tr>
<tr class="separator:a1dfb7566369027bc94437c6973469c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0a303b68788b49895e85f4a80fb061aa"><td class="memItemLeft" align="right" valign="top">typedef unsigned int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">sc_hash_function_t</a>) (const void *v, const void *u)</td></tr>
<tr class="memdesc:a0a303b68788b49895e85f4a80fb061aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute a hash value of an object.  <a href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">More...</a><br /></td></tr>
<tr class="separator:a0a303b68788b49895e85f4a80fb061aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3afb1f6aca73ea1b310e6d91c65c36"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">sc_equal_function_t</a>) (const void *v1, const void *v2, const void *u)</td></tr>
<tr class="memdesc:afa3afb1f6aca73ea1b310e6d91c65c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check equality of two objects.  <a href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">More...</a><br /></td></tr>
<tr class="separator:afa3afb1f6aca73ea1b310e6d91c65c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377b6d1c8ddd0e9fd27113be5ac70bf7"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">sc_hash_foreach_t</a>) (void **v, const void *u)</td></tr>
<tr class="memdesc:a377b6d1c8ddd0e9fd27113be5ac70bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call on every data item of a hash table or hash array.  <a href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">More...</a><br /></td></tr>
<tr class="separator:a377b6d1c8ddd0e9fd27113be5ac70bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619346753d2a15625bda06835c83e5e2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__array.html">sc_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a></td></tr>
<tr class="memdesc:a619346753d2a15625bda06835c83e5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> object provides a dynamic array of equal-size elements.  <a href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">More...</a><br /></td></tr>
<tr class="separator:a619346753d2a15625bda06835c83e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783687760fbe3e2c531cd99a695ab7e1"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a783687760fbe3e2c531cd99a695ab7e1">sc_array_type_t</a>) (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t index, void *data)</td></tr>
<tr class="memdesc:a783687760fbe3e2c531cd99a695ab7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine the enumerable type of an object in an array.  <a href="sc__containers_8h.html#a783687760fbe3e2c531cd99a695ab7e1">More...</a><br /></td></tr>
<tr class="separator:a783687760fbe3e2c531cd99a695ab7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd613ca16520c612c4dd38d0ce3070"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__mstamp.html">sc_mstamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a></td></tr>
<tr class="memdesc:ab9cd613ca16520c612c4dd38d0ce3070"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data container to create memory items of the same size.  <a href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">More...</a><br /></td></tr>
<tr class="separator:ab9cd613ca16520c612c4dd38d0ce3070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ef6fe706382d2d67a66fba72d0bf4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__mempool.html">sc_mempool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a></td></tr>
<tr class="memdesc:a9d4ef6fe706382d2d67a66fba72d0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__mempool.html" title="The sc_mempool object provides a large pool of equal-size elements.">sc_mempool</a> object provides a large pool of equal-size elements.  <a href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">More...</a><br /></td></tr>
<tr class="separator:a9d4ef6fe706382d2d67a66fba72d0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fdd18bc0086f8cdba6971f505dcbb0"><td class="memItemLeft" align="right" valign="top"><a id="a88fdd18bc0086f8cdba6971f505dcbb0"></a>
typedef struct <a class="el" href="structsc__link.html">sc_link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a></td></tr>
<tr class="memdesc:a88fdd18bc0086f8cdba6971f505dcbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__link.html" title="The sc_link structure is one link of a linked list.">sc_link</a> structure is one link of a linked list. <br /></td></tr>
<tr class="separator:a88fdd18bc0086f8cdba6971f505dcbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7968381a6d40057f3af6acec771a70"><td class="memItemLeft" align="right" valign="top"><a id="a0d7968381a6d40057f3af6acec771a70"></a>
typedef struct <a class="el" href="structsc__list.html">sc_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a></td></tr>
<tr class="memdesc:a0d7968381a6d40057f3af6acec771a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__list.html" title="The sc_list object provides a linked list.">sc_list</a> object provides a linked list. <br /></td></tr>
<tr class="separator:a0d7968381a6d40057f3af6acec771a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7966c694715add48d4d3ac86b330592b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__hash.html">sc_hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a></td></tr>
<tr class="memdesc:a7966c694715add48d4d3ac86b330592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__hash.html" title="The sc_hash implements a hash table.">sc_hash</a> implements a hash table.  <a href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">More...</a><br /></td></tr>
<tr class="separator:a7966c694715add48d4d3ac86b330592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be514049863b2889ab2a6e028192b4d"><td class="memItemLeft" align="right" valign="top"><a id="a0be514049863b2889ab2a6e028192b4d"></a>
typedef struct sc_hash_array_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0be514049863b2889ab2a6e028192b4d">sc_hash_array_data_t</a></td></tr>
<tr class="memdesc:a0be514049863b2889ab2a6e028192b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal context structure for <a class="el" href="structsc__hash__array.html">sc_hash_array</a>. <br /></td></tr>
<tr class="separator:a0be514049863b2889ab2a6e028192b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663eb6e36259a43ad0e583b19e9926c7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__hash__array.html">sc_hash_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a></td></tr>
<tr class="memdesc:a663eb6e36259a43ad0e583b19e9926c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__hash__array.html" title="The sc_hash_array implements an array backed up by a hash table.">sc_hash_array</a> implements an array backed up by a hash table.  <a href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">More...</a><br /></td></tr>
<tr class="separator:a663eb6e36259a43ad0e583b19e9926c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d3d31f993e731607abaad2fd43ee6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsc__recycle__array.html">sc_recycle_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a></td></tr>
<tr class="memdesc:a135d3d31f993e731607abaad2fd43ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structsc__recycle__array.html" title="The sc_recycle_array object provides an array of slots that can be reused.">sc_recycle_array</a> object provides an array of slots that can be reused.  <a href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">More...</a><br /></td></tr>
<tr class="separator:a135d3d31f993e731607abaad2fd43ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9c156f095e1050cd568689fa3615a7ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9c156f095e1050cd568689fa3615a7ed">sc_array_memory_used</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, int is_dynamic)</td></tr>
<tr class="memdesc:a9c156f095e1050cd568689fa3615a7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by an array.  <a href="sc__containers_8h.html#a9c156f095e1050cd568689fa3615a7ed">More...</a><br /></td></tr>
<tr class="separator:a9c156f095e1050cd568689fa3615a7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad880facede1dd567bd4da71fc8b46dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ad880facede1dd567bd4da71fc8b46dcd">sc_array_new</a> (size_t elem_size)</td></tr>
<tr class="memdesc:ad880facede1dd567bd4da71fc8b46dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new array structure with 0 elements.  <a href="sc__containers_8h.html#ad880facede1dd567bd4da71fc8b46dcd">More...</a><br /></td></tr>
<tr class="separator:ad880facede1dd567bd4da71fc8b46dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995cca28e6413132e14691834e279504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a995cca28e6413132e14691834e279504">sc_array_new_count</a> (size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a995cca28e6413132e14691834e279504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new array structure with a given length (number of elements).  <a href="sc__containers_8h.html#a995cca28e6413132e14691834e279504">More...</a><br /></td></tr>
<tr class="separator:a995cca28e6413132e14691834e279504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff8923e5659a46da89edfabb089d3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#acff8923e5659a46da89edfabb089d3f4">sc_array_new_view</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t offset, size_t length)</td></tr>
<tr class="memdesc:acff8923e5659a46da89edfabb089d3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new view of an existing sc_array_t.  <a href="sc__containers_8h.html#acff8923e5659a46da89edfabb089d3f4">More...</a><br /></td></tr>
<tr class="separator:acff8923e5659a46da89edfabb089d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a45ac4f8d8add15a6838cb0ec9c3319be">sc_array_new_data</a> (void *base, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new view of an existing plain C array.  <a href="sc__containers_8h.html#a45ac4f8d8add15a6838cb0ec9c3319be">More...</a><br /></td></tr>
<tr class="separator:a45ac4f8d8add15a6838cb0ec9c3319be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9538f758ce0adf6f61c7091dff1a693a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9538f758ce0adf6f61c7091dff1a693a">sc_array_destroy</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a9538f758ce0adf6f61c7091dff1a693a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an array structure.  <a href="sc__containers_8h.html#a9538f758ce0adf6f61c7091dff1a693a">More...</a><br /></td></tr>
<tr class="separator:a9538f758ce0adf6f61c7091dff1a693a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a53cdb69696fe2dbf8dd8dda821155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a66a53cdb69696fe2dbf8dd8dda821155">sc_array_destroy_null</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> **parray)</td></tr>
<tr class="memdesc:a66a53cdb69696fe2dbf8dd8dda821155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an array structure and sets the pointer to NULL.  <a href="sc__containers_8h.html#a66a53cdb69696fe2dbf8dd8dda821155">More...</a><br /></td></tr>
<tr class="separator:a66a53cdb69696fe2dbf8dd8dda821155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253a39f46eda1adfc12871e3e52e2251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a253a39f46eda1adfc12871e3e52e2251">sc_array_init</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t elem_size)</td></tr>
<tr class="memdesc:a253a39f46eda1adfc12871e3e52e2251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) array structure.  <a href="sc__containers_8h.html#a253a39f46eda1adfc12871e3e52e2251">More...</a><br /></td></tr>
<tr class="separator:a253a39f46eda1adfc12871e3e52e2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34588e4788f67b33bea0c99dc34e0473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a34588e4788f67b33bea0c99dc34e0473">sc_array_init_size</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a34588e4788f67b33bea0c99dc34e0473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) array structure and allocates a given number of elements.  <a href="sc__containers_8h.html#a34588e4788f67b33bea0c99dc34e0473">More...</a><br /></td></tr>
<tr class="separator:a34588e4788f67b33bea0c99dc34e0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123c042db61b86447f9c68edff6c275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab123c042db61b86447f9c68edff6c275">sc_array_init_count</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:ab123c042db61b86447f9c68edff6c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) array structure and allocates a given number of elements.  <a href="sc__containers_8h.html#ab123c042db61b86447f9c68edff6c275">More...</a><br /></td></tr>
<tr class="separator:ab123c042db61b86447f9c68edff6c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa7c755a6fdc7f4e3c490d9edb786cc5d">sc_array_init_view</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *view, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t offset, size_t length)</td></tr>
<tr class="memdesc:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) view from existing sc_array_t.  <a href="sc__containers_8h.html#aa7c755a6fdc7f4e3c490d9edb786cc5d">More...</a><br /></td></tr>
<tr class="separator:aa7c755a6fdc7f4e3c490d9edb786cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225c9354782d37590e63d704124cd113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a225c9354782d37590e63d704124cd113">sc_array_init_reshape</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *view, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a225c9354782d37590e63d704124cd113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an already allocated (or static) view from existing sc_array_t.  <a href="sc__containers_8h.html#a225c9354782d37590e63d704124cd113">More...</a><br /></td></tr>
<tr class="separator:a225c9354782d37590e63d704124cd113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314b3cdbde02bc48303c9d60391286ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a314b3cdbde02bc48303c9d60391286ee">sc_array_init_data</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *view, void *base, size_t elem_size, size_t elem_count)</td></tr>
<tr class="memdesc:a314b3cdbde02bc48303c9d60391286ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already allocated (or static) view from given plain C data.  <a href="sc__containers_8h.html#a314b3cdbde02bc48303c9d60391286ee">More...</a><br /></td></tr>
<tr class="separator:a314b3cdbde02bc48303c9d60391286ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb264d085512739969ce4fb6d643d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aacb264d085512739969ce4fb6d643d7a">sc_array_memset</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, int c)</td></tr>
<tr class="memdesc:aacb264d085512739969ce4fb6d643d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run memset on the array storage.  <a href="sc__containers_8h.html#aacb264d085512739969ce4fb6d643d7a">More...</a><br /></td></tr>
<tr class="separator:aacb264d085512739969ce4fb6d643d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6df54afbedf05d9cf789c5ebb7599ab4">sc_array_reset</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the array count to zero and frees all elements.  <a href="sc__containers_8h.html#a6df54afbedf05d9cf789c5ebb7599ab4">More...</a><br /></td></tr>
<tr class="separator:a6df54afbedf05d9cf789c5ebb7599ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6536ee67b1b02848dd529ffd1e3fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#acd6536ee67b1b02848dd529ffd1e3fec">sc_array_truncate</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:acd6536ee67b1b02848dd529ffd1e3fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the array count to zero, but does not free elements.  <a href="sc__containers_8h.html#acd6536ee67b1b02848dd529ffd1e3fec">More...</a><br /></td></tr>
<tr class="separator:acd6536ee67b1b02848dd529ffd1e3fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ec6fe1bb8a06481c6677e63efc76ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a30ec6fe1bb8a06481c6677e63efc76ec">sc_array_rewind</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t new_count)</td></tr>
<tr class="memdesc:a30ec6fe1bb8a06481c6677e63efc76ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorten an array without reallocating it.  <a href="sc__containers_8h.html#a30ec6fe1bb8a06481c6677e63efc76ec">More...</a><br /></td></tr>
<tr class="separator:a30ec6fe1bb8a06481c6677e63efc76ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d8488f231972c68d44eb6239c9cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a584d8488f231972c68d44eb6239c9cd8">sc_array_resize</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t new_count)</td></tr>
<tr class="memdesc:a584d8488f231972c68d44eb6239c9cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element count to new_count.  <a href="sc__containers_8h.html#a584d8488f231972c68d44eb6239c9cd8">More...</a><br /></td></tr>
<tr class="separator:a584d8488f231972c68d44eb6239c9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396352376b97fd861557f4b844ba0730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a396352376b97fd861557f4b844ba0730">sc_array_copy</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *dest, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *src)</td></tr>
<tr class="memdesc:a396352376b97fd861557f4b844ba0730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of one array into another.  <a href="sc__containers_8h.html#a396352376b97fd861557f4b844ba0730">More...</a><br /></td></tr>
<tr class="separator:a396352376b97fd861557f4b844ba0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6838c27c4655cb9e3637e2277be1371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac6838c27c4655cb9e3637e2277be1371">sc_array_copy_into</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *dest, size_t dest_offset, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *src)</td></tr>
<tr class="memdesc:ac6838c27c4655cb9e3637e2277be1371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of one array into some portion of another.  <a href="sc__containers_8h.html#ac6838c27c4655cb9e3637e2277be1371">More...</a><br /></td></tr>
<tr class="separator:ac6838c27c4655cb9e3637e2277be1371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d66f0bf86f9f8975611dda4d0b2880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ae1d66f0bf86f9f8975611dda4d0b2880">sc_array_move_part</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *dest, size_t dest_offset, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *src, size_t src_offset, size_t count)</td></tr>
<tr class="memdesc:ae1d66f0bf86f9f8975611dda4d0b2880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy part of one array into another using memmove (3).  <a href="sc__containers_8h.html#ae1d66f0bf86f9f8975611dda4d0b2880">More...</a><br /></td></tr>
<tr class="separator:ae1d66f0bf86f9f8975611dda4d0b2880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750f7188a30c8c2756c77d70967b0caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a750f7188a30c8c2756c77d70967b0caf">sc_array_sort</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:a750f7188a30c8c2756c77d70967b0caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array in ascending order wrt.  <a href="sc__containers_8h.html#a750f7188a30c8c2756c77d70967b0caf">More...</a><br /></td></tr>
<tr class="separator:a750f7188a30c8c2756c77d70967b0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab930cdd0da30cd639b20a639990568e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab930cdd0da30cd639b20a639990568e1">sc_array_is_sorted</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:ab930cdd0da30cd639b20a639990568e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the array is sorted wrt.  <a href="sc__containers_8h.html#ab930cdd0da30cd639b20a639990568e1">More...</a><br /></td></tr>
<tr class="separator:ab930cdd0da30cd639b20a639990568e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc880037e9e90efb76648a5faa926e5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#adc880037e9e90efb76648a5faa926e5b">sc_array_is_equal</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *other)</td></tr>
<tr class="memdesc:adc880037e9e90efb76648a5faa926e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two arrays have equal size, count, and content.  <a href="sc__containers_8h.html#adc880037e9e90efb76648a5faa926e5b">More...</a><br /></td></tr>
<tr class="separator:adc880037e9e90efb76648a5faa926e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be396714f4ea39005cab1bc666666a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a7be396714f4ea39005cab1bc666666a6">sc_array_uniq</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:a7be396714f4ea39005cab1bc666666a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed duplicate entries from a sorted array.  <a href="sc__containers_8h.html#a7be396714f4ea39005cab1bc666666a6">More...</a><br /></td></tr>
<tr class="separator:a7be396714f4ea39005cab1bc666666a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa0759d2b44ed0aadb8c325f7bd5f5449">sc_array_bsearch</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, const void *key, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search on an array.  <a href="sc__containers_8h.html#aa0759d2b44ed0aadb8c325f7bd5f5449">More...</a><br /></td></tr>
<tr class="separator:aa0759d2b44ed0aadb8c325f7bd5f5449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2072803b22a940c6e39498940768c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a4ef2072803b22a940c6e39498940768c">sc_array_split</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *offsets, size_t num_types, <a class="el" href="sc__containers_8h.html#a783687760fbe3e2c531cd99a695ab7e1">sc_array_type_t</a> type_fn, void *data)</td></tr>
<tr class="memdesc:a4ef2072803b22a940c6e39498940768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the offsets of groups of enumerable types in an array.  <a href="sc__containers_8h.html#a4ef2072803b22a940c6e39498940768c">More...</a><br /></td></tr>
<tr class="separator:a4ef2072803b22a940c6e39498940768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba51287db7e298935bd1fda5557fbacf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aba51287db7e298935bd1fda5557fbacf">sc_array_is_permutation</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:aba51287db7e298935bd1fda5557fbacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether <em>array</em> is an array of size_t's whose entries include every integer 0 &lt;= i &lt; array-&gt;elem_count.  <a href="sc__containers_8h.html#aba51287db7e298935bd1fda5557fbacf">More...</a><br /></td></tr>
<tr class="separator:aba51287db7e298935bd1fda5557fbacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05188345c402a4374c9e7ed4753e5c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a05188345c402a4374c9e7ed4753e5c8e">sc_array_permute</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *newindices, int keepperm)</td></tr>
<tr class="memdesc:a05188345c402a4374c9e7ed4753e5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given permutation <em>newindices</em>, permute <em>array</em> in place.  <a href="sc__containers_8h.html#a05188345c402a4374c9e7ed4753e5c8e">More...</a><br /></td></tr>
<tr class="separator:a05188345c402a4374c9e7ed4753e5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8a3c56854a5efc06605541278ea3dd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aff8a3c56854a5efc06605541278ea3dd">sc_array_checksum</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array)</td></tr>
<tr class="memdesc:aff8a3c56854a5efc06605541278ea3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the adler32 checksum of array data (see zlib documentation).  <a href="sc__containers_8h.html#aff8a3c56854a5efc06605541278ea3dd">More...</a><br /></td></tr>
<tr class="separator:aff8a3c56854a5efc06605541278ea3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd0c405a3d83dfc251de2a390f43d88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aadd0c405a3d83dfc251de2a390f43d88">sc_array_pqueue_add</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, void *temp, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:aadd0c405a3d83dfc251de2a390f43d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to a priority queue.  <a href="sc__containers_8h.html#aadd0c405a3d83dfc251de2a390f43d88">More...</a><br /></td></tr>
<tr class="separator:aadd0c405a3d83dfc251de2a390f43d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ec1c3d19267b204a2f756fe428f196"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#af8ec1c3d19267b204a2f756fe428f196">sc_array_pqueue_pop</a> (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, void *result, int(*compar)(const void *, const void *))</td></tr>
<tr class="memdesc:af8ec1c3d19267b204a2f756fe428f196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the smallest element from a priority queue.  <a href="sc__containers_8h.html#af8ec1c3d19267b204a2f756fe428f196">More...</a><br /></td></tr>
<tr class="separator:af8ec1c3d19267b204a2f756fe428f196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a667b4bf2d1777550917a00ca1ee46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac9a667b4bf2d1777550917a00ca1ee46">sc_mstamp_init</a> (<a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *mst, size_t stamp_unit, size_t elem_size)</td></tr>
<tr class="memdesc:ac9a667b4bf2d1777550917a00ca1ee46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a memory stamp container.  <a href="sc__containers_8h.html#ac9a667b4bf2d1777550917a00ca1ee46">More...</a><br /></td></tr>
<tr class="separator:ac9a667b4bf2d1777550917a00ca1ee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e36faece884b10645816c2b85cd6a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a3e36faece884b10645816c2b85cd6a27">sc_mstamp_reset</a> (<a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *mst)</td></tr>
<tr class="memdesc:a3e36faece884b10645816c2b85cd6a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory in a stamp structure and all items previously returned.  <a href="sc__containers_8h.html#a3e36faece884b10645816c2b85cd6a27">More...</a><br /></td></tr>
<tr class="separator:a3e36faece884b10645816c2b85cd6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e50a88d5c99bc2a7f1749a77fe26641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a9e50a88d5c99bc2a7f1749a77fe26641">sc_mstamp_truncate</a> (<a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *mst)</td></tr>
<tr class="memdesc:a9e50a88d5c99bc2a7f1749a77fe26641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory in a stamp structure and initialize it anew.  <a href="sc__containers_8h.html#a9e50a88d5c99bc2a7f1749a77fe26641">More...</a><br /></td></tr>
<tr class="separator:a9e50a88d5c99bc2a7f1749a77fe26641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d1bec5cb6c6826ff4095e3052437bf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#af9d1bec5cb6c6826ff4095e3052437bf">sc_mstamp_alloc</a> (<a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *mst)</td></tr>
<tr class="memdesc:af9d1bec5cb6c6826ff4095e3052437bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new item.  <a href="sc__containers_8h.html#af9d1bec5cb6c6826ff4095e3052437bf">More...</a><br /></td></tr>
<tr class="separator:af9d1bec5cb6c6826ff4095e3052437bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fa1c49411f637464a99522a3370145"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a41fa1c49411f637464a99522a3370145">sc_mstamp_memory_used</a> (<a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *mst)</td></tr>
<tr class="memdesc:a41fa1c49411f637464a99522a3370145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return memory size in bytes of all data allocated in the container.  <a href="sc__containers_8h.html#a41fa1c49411f637464a99522a3370145">More...</a><br /></td></tr>
<tr class="separator:a41fa1c49411f637464a99522a3370145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73235130bba53a9ed8b07ddfa27fadae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a73235130bba53a9ed8b07ddfa27fadae">sc_mempool_memory_used</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a73235130bba53a9ed8b07ddfa27fadae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a memory pool.  <a href="sc__containers_8h.html#a73235130bba53a9ed8b07ddfa27fadae">More...</a><br /></td></tr>
<tr class="separator:a73235130bba53a9ed8b07ddfa27fadae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab416c24d85ffd174f0dd3ad89c4c1163">sc_mempool_new</a> (size_t elem_size)</td></tr>
<tr class="memdesc:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mempool structure with the zero_and_persist option off.  <a href="sc__containers_8h.html#ab416c24d85ffd174f0dd3ad89c4c1163">More...</a><br /></td></tr>
<tr class="separator:ab416c24d85ffd174f0dd3ad89c4c1163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561743511cacdfaacb29ad28442a5a4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a561743511cacdfaacb29ad28442a5a4c">sc_mempool_new_zero_and_persist</a> (size_t elem_size)</td></tr>
<tr class="memdesc:a561743511cacdfaacb29ad28442a5a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mempool structure with the zero_and_persist option on.  <a href="sc__containers_8h.html#a561743511cacdfaacb29ad28442a5a4c">More...</a><br /></td></tr>
<tr class="separator:a561743511cacdfaacb29ad28442a5a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8778c147e092b73df13afdbc2e4c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aac8778c147e092b73df13afdbc2e4c84">sc_mempool_init</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *mempool, size_t elem_size)</td></tr>
<tr class="memdesc:aac8778c147e092b73df13afdbc2e4c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as sc_mempool_new, but for an already allocated object.  <a href="sc__containers_8h.html#aac8778c147e092b73df13afdbc2e4c84">More...</a><br /></td></tr>
<tr class="separator:aac8778c147e092b73df13afdbc2e4c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ecbb2b02cf93632c79c7307f5238ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a45ecbb2b02cf93632c79c7307f5238ba">sc_mempool_destroy</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a45ecbb2b02cf93632c79c7307f5238ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mempool structure.  <a href="sc__containers_8h.html#a45ecbb2b02cf93632c79c7307f5238ba">More...</a><br /></td></tr>
<tr class="separator:a45ecbb2b02cf93632c79c7307f5238ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b560f3010038ed71dad8635eb747fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a81b560f3010038ed71dad8635eb747fd">sc_mempool_destroy_null</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> **pmempool)</td></tr>
<tr class="memdesc:a81b560f3010038ed71dad8635eb747fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mempool structure.  <a href="sc__containers_8h.html#a81b560f3010038ed71dad8635eb747fd">More...</a><br /></td></tr>
<tr class="separator:a81b560f3010038ed71dad8635eb747fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2a7bbce18983023e61ff681e66d94f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a1e2a7bbce18983023e61ff681e66d94f">sc_mempool_reset</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:a1e2a7bbce18983023e61ff681e66d94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as sc_mempool_destroy, but does not free the pointer.  <a href="sc__containers_8h.html#a1e2a7bbce18983023e61ff681e66d94f">More...</a><br /></td></tr>
<tr class="separator:a1e2a7bbce18983023e61ff681e66d94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab483d01f1670c336d9cf76a8a2789d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab483d01f1670c336d9cf76a8a2789d21">sc_mempool_truncate</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *mempool)</td></tr>
<tr class="memdesc:ab483d01f1670c336d9cf76a8a2789d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates all previously returned pointers, resets count to 0.  <a href="sc__containers_8h.html#ab483d01f1670c336d9cf76a8a2789d21">More...</a><br /></td></tr>
<tr class="separator:ab483d01f1670c336d9cf76a8a2789d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#abc4ec6b2855dcb3125310f6ad2928ca1">sc_list_memory_used</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, int is_dynamic)</td></tr>
<tr class="memdesc:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total memory used by a list.  <a href="sc__containers_8h.html#abc4ec6b2855dcb3125310f6ad2928ca1">More...</a><br /></td></tr>
<tr class="separator:abc4ec6b2855dcb3125310f6ad2928ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed388e36eb3088d911d68f995be3b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a16ed388e36eb3088d911d68f995be3b1">sc_list_new</a> (<a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a16ed388e36eb3088d911d68f995be3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new, empty linked list.  <a href="sc__containers_8h.html#a16ed388e36eb3088d911d68f995be3b1">More...</a><br /></td></tr>
<tr class="separator:a16ed388e36eb3088d911d68f995be3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d366868c0011ee034b4e1b5d6f701f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab9d366868c0011ee034b4e1b5d6f701f">sc_list_destroy</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:ab9d366868c0011ee034b4e1b5d6f701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a linked list structure in O(N).  <a href="sc__containers_8h.html#ab9d366868c0011ee034b4e1b5d6f701f">More...</a><br /></td></tr>
<tr class="separator:ab9d366868c0011ee034b4e1b5d6f701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345f4f800f46d60d612c6d9545758dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a2345f4f800f46d60d612c6d9545758dd">sc_list_init</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, <a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a2345f4f800f46d60d612c6d9545758dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a list object with an external link allocator.  <a href="sc__containers_8h.html#a2345f4f800f46d60d612c6d9545758dd">More...</a><br /></td></tr>
<tr class="separator:a2345f4f800f46d60d612c6d9545758dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab87b22d2b61f04d3c73d93e9218b97c7">sc_list_reset</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from a list in O(N).  <a href="sc__containers_8h.html#ab87b22d2b61f04d3c73d93e9218b97c7">More...</a><br /></td></tr>
<tr class="separator:ab87b22d2b61f04d3c73d93e9218b97c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5934247f1587a5376772ec2d035f812f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a5934247f1587a5376772ec2d035f812f">sc_list_unlink</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:a5934247f1587a5376772ec2d035f812f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink all list elements without returning them to the mempool.  <a href="sc__containers_8h.html#a5934247f1587a5376772ec2d035f812f">More...</a><br /></td></tr>
<tr class="separator:a5934247f1587a5376772ec2d035f812f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d609be9c0904f955ea15eddab01ef12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6d609be9c0904f955ea15eddab01ef12">sc_list_prepend</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, void *data)</td></tr>
<tr class="memdesc:a6d609be9c0904f955ea15eddab01ef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list element at the beginning of the list.  <a href="sc__containers_8h.html#a6d609be9c0904f955ea15eddab01ef12">More...</a><br /></td></tr>
<tr class="separator:a6d609be9c0904f955ea15eddab01ef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfae475a3fb1f3fe8e0f5a7548262065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#adfae475a3fb1f3fe8e0f5a7548262065">sc_list_append</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, void *data)</td></tr>
<tr class="memdesc:adfae475a3fb1f3fe8e0f5a7548262065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a list element at the end of the list.  <a href="sc__containers_8h.html#adfae475a3fb1f3fe8e0f5a7548262065">More...</a><br /></td></tr>
<tr class="separator:adfae475a3fb1f3fe8e0f5a7548262065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b94f6cf468b02dbaabd780e162cbeaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0b94f6cf468b02dbaabd780e162cbeaa">sc_list_insert</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, <a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *pred, void *data)</td></tr>
<tr class="memdesc:a0b94f6cf468b02dbaabd780e162cbeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element after a given list position.  <a href="sc__containers_8h.html#a0b94f6cf468b02dbaabd780e162cbeaa">More...</a><br /></td></tr>
<tr class="separator:a0b94f6cf468b02dbaabd780e162cbeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1dfcc941294ac2b6898db6b798938d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aaf1dfcc941294ac2b6898db6b798938d">sc_list_remove</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list, <a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *pred)</td></tr>
<tr class="memdesc:aaf1dfcc941294ac2b6898db6b798938d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element after a given list position.  <a href="sc__containers_8h.html#aaf1dfcc941294ac2b6898db6b798938d">More...</a><br /></td></tr>
<tr class="separator:aaf1dfcc941294ac2b6898db6b798938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcaa9043e79854360ab37bdc670e668"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#affcaa9043e79854360ab37bdc670e668">sc_list_pop</a> (<a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *list)</td></tr>
<tr class="memdesc:affcaa9043e79854360ab37bdc670e668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the front of the list.  <a href="sc__containers_8h.html#affcaa9043e79854360ab37bdc670e668">More...</a><br /></td></tr>
<tr class="separator:affcaa9043e79854360ab37bdc670e668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f50ed06f72928a512bf013da66231dd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a5f50ed06f72928a512bf013da66231dd">sc_hash_function_string</a> (const void *s, const void *u)</td></tr>
<tr class="memdesc:a5f50ed06f72928a512bf013da66231dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash value from a null-terminated string.  <a href="sc__containers_8h.html#a5f50ed06f72928a512bf013da66231dd">More...</a><br /></td></tr>
<tr class="separator:a5f50ed06f72928a512bf013da66231dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61448f834b749daa38248ad391417e0a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a61448f834b749daa38248ad391417e0a">sc_hash_memory_used</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a61448f834b749daa38248ad391417e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a hash table.  <a href="sc__containers_8h.html#a61448f834b749daa38248ad391417e0a">More...</a><br /></td></tr>
<tr class="separator:a61448f834b749daa38248ad391417e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79301891a134c0765dd8770cd88545d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a79301891a134c0765dd8770cd88545d1">sc_hash_new</a> (<a class="el" href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">sc_hash_function_t</a> hash_fn, <a class="el" href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">sc_equal_function_t</a> equal_fn, void *user_data, <a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *allocator)</td></tr>
<tr class="memdesc:a79301891a134c0765dd8770cd88545d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hash table.  <a href="sc__containers_8h.html#a79301891a134c0765dd8770cd88545d1">More...</a><br /></td></tr>
<tr class="separator:a79301891a134c0765dd8770cd88545d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485f83fdfee14e4a14573f4efe7c108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a4485f83fdfee14e4a14573f4efe7c108">sc_hash_destroy</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a4485f83fdfee14e4a14573f4efe7c108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a hash table.  <a href="sc__containers_8h.html#a4485f83fdfee14e4a14573f4efe7c108">More...</a><br /></td></tr>
<tr class="separator:a4485f83fdfee14e4a14573f4efe7c108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50845e587caa053395c696b4fdb274e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a50845e587caa053395c696b4fdb274e1">sc_hash_destroy_null</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> **phash)</td></tr>
<tr class="memdesc:a50845e587caa053395c696b4fdb274e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a hash table and set its pointer to NULL.  <a href="sc__containers_8h.html#a50845e587caa053395c696b4fdb274e1">More...</a><br /></td></tr>
<tr class="separator:a50845e587caa053395c696b4fdb274e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6018b3a4e5c51501d52094335bb85d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6018b3a4e5c51501d52094335bb85d11">sc_hash_truncate</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:a6018b3a4e5c51501d52094335bb85d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all entries from a hash table in O(N).  <a href="sc__containers_8h.html#a6018b3a4e5c51501d52094335bb85d11">More...</a><br /></td></tr>
<tr class="separator:a6018b3a4e5c51501d52094335bb85d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2992a0fc01581345b413f460a4b7927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab2992a0fc01581345b413f460a4b7927">sc_hash_unlink</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ab2992a0fc01581345b413f460a4b7927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink all hash elements without returning them to the mempool.  <a href="sc__containers_8h.html#ab2992a0fc01581345b413f460a4b7927">More...</a><br /></td></tr>
<tr class="separator:ab2992a0fc01581345b413f460a4b7927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe8987fef58946b5327ea202cfb9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ab6fe8987fef58946b5327ea202cfb9c7">sc_hash_unlink_destroy</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ab6fe8987fef58946b5327ea202cfb9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same effect as unlink and destroy, but in O(1).  <a href="sc__containers_8h.html#ab6fe8987fef58946b5327ea202cfb9c7">More...</a><br /></td></tr>
<tr class="separator:ab6fe8987fef58946b5327ea202cfb9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac491f058bd4a47555c203e94db47f37c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac491f058bd4a47555c203e94db47f37c">sc_hash_lookup</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash, void *v, void ***found)</td></tr>
<tr class="memdesc:ac491f058bd4a47555c203e94db47f37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an object is contained in the hash table.  <a href="sc__containers_8h.html#ac491f058bd4a47555c203e94db47f37c">More...</a><br /></td></tr>
<tr class="separator:ac491f058bd4a47555c203e94db47f37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471ac510c147c97b396a980d7cfc6852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a471ac510c147c97b396a980d7cfc6852">sc_hash_insert_unique</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash, void *v, void ***found)</td></tr>
<tr class="memdesc:a471ac510c147c97b396a980d7cfc6852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into a hash table if it is not contained already.  <a href="sc__containers_8h.html#a471ac510c147c97b396a980d7cfc6852">More...</a><br /></td></tr>
<tr class="separator:a471ac510c147c97b396a980d7cfc6852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3368ef4a371e8128a96e159ea28c3c63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a3368ef4a371e8128a96e159ea28c3c63">sc_hash_remove</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash, void *v, void **found)</td></tr>
<tr class="memdesc:a3368ef4a371e8128a96e159ea28c3c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from a hash table.  <a href="sc__containers_8h.html#a3368ef4a371e8128a96e159ea28c3c63">More...</a><br /></td></tr>
<tr class="separator:a3368ef4a371e8128a96e159ea28c3c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbe548fa780a3d3ce1a719075eb3d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#accbe548fa780a3d3ce1a719075eb3d5a">sc_hash_foreach</a> (<a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash, <a class="el" href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">sc_hash_foreach_t</a> fn)</td></tr>
<tr class="memdesc:accbe548fa780a3d3ce1a719075eb3d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a callback for every member of the hash table.  <a href="sc__containers_8h.html#accbe548fa780a3d3ce1a719075eb3d5a">More...</a><br /></td></tr>
<tr class="separator:accbe548fa780a3d3ce1a719075eb3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5d86966197595ae5ecd9471af8e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ae1b5d86966197595ae5ecd9471af8e05">sc_hash_print_statistics</a> (int package_id, int log_priority, <a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *hash)</td></tr>
<tr class="memdesc:ae1b5d86966197595ae5ecd9471af8e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and print statistical information about the occupancy.  <a href="sc__containers_8h.html#ae1b5d86966197595ae5ecd9471af8e05">More...</a><br /></td></tr>
<tr class="separator:ae1b5d86966197595ae5ecd9471af8e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a287e5cf0f7ea5b4a16e534a19fffa595">sc_hash_array_memory_used</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *ha)</td></tr>
<tr class="memdesc:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the memory used by a hash array.  <a href="sc__containers_8h.html#a287e5cf0f7ea5b4a16e534a19fffa595">More...</a><br /></td></tr>
<tr class="separator:a287e5cf0f7ea5b4a16e534a19fffa595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aa086b8ede8a18ebdcfb690d6bf73e86a">sc_hash_array_new</a> (size_t elem_size, <a class="el" href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">sc_hash_function_t</a> hash_fn, <a class="el" href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">sc_equal_function_t</a> equal_fn, void *user_data)</td></tr>
<tr class="memdesc:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hash array.  <a href="sc__containers_8h.html#aa086b8ede8a18ebdcfb690d6bf73e86a">More...</a><br /></td></tr>
<tr class="separator:aa086b8ede8a18ebdcfb690d6bf73e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe72e9f693035fffc01e42dbd1f52859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#abe72e9f693035fffc01e42dbd1f52859">sc_hash_array_destroy</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:abe72e9f693035fffc01e42dbd1f52859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a hash array.  <a href="sc__containers_8h.html#abe72e9f693035fffc01e42dbd1f52859">More...</a><br /></td></tr>
<tr class="separator:abe72e9f693035fffc01e42dbd1f52859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36fbe3c869bded837f9976c20ea7b95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#ac36fbe3c869bded837f9976c20ea7b95">sc_hash_array_is_valid</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:ac36fbe3c869bded837f9976c20ea7b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the internal consistency of a hash array.  <a href="sc__containers_8h.html#ac36fbe3c869bded837f9976c20ea7b95">More...</a><br /></td></tr>
<tr class="separator:ac36fbe3c869bded837f9976c20ea7b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8557bf638bc729901df79c86f05e04c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a8557bf638bc729901df79c86f05e04c4">sc_hash_array_truncate</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array)</td></tr>
<tr class="memdesc:a8557bf638bc729901df79c86f05e04c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the hash array.  <a href="sc__containers_8h.html#a8557bf638bc729901df79c86f05e04c4">More...</a><br /></td></tr>
<tr class="separator:a8557bf638bc729901df79c86f05e04c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1743a8aa716313f45e754b05f4066d07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a1743a8aa716313f45e754b05f4066d07">sc_hash_array_lookup</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array, void *v, size_t *position)</td></tr>
<tr class="memdesc:a1743a8aa716313f45e754b05f4066d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an object is contained in a hash array.  <a href="sc__containers_8h.html#a1743a8aa716313f45e754b05f4066d07">More...</a><br /></td></tr>
<tr class="separator:a1743a8aa716313f45e754b05f4066d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc4c1933168da0ac3b075df053ceab3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a0cc4c1933168da0ac3b075df053ceab3">sc_hash_array_insert_unique</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array, void *v, size_t *position)</td></tr>
<tr class="memdesc:a0cc4c1933168da0ac3b075df053ceab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into a hash array if it is not contained already.  <a href="sc__containers_8h.html#a0cc4c1933168da0ac3b075df053ceab3">More...</a><br /></td></tr>
<tr class="separator:a0cc4c1933168da0ac3b075df053ceab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d905b28782d768b687cd0bf0d75cf5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a6d905b28782d768b687cd0bf0d75cf5a">sc_hash_array_foreach</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array, <a class="el" href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">sc_hash_foreach_t</a> fn)</td></tr>
<tr class="memdesc:a6d905b28782d768b687cd0bf0d75cf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a callback for every member of the hash array.  <a href="sc__containers_8h.html#a6d905b28782d768b687cd0bf0d75cf5a">More...</a><br /></td></tr>
<tr class="separator:a6d905b28782d768b687cd0bf0d75cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#aaf5b81adba0e4c4c3c557dcf7613f36b">sc_hash_array_rip</a> (<a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *hash_array, <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *rip)</td></tr>
<tr class="memdesc:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the array data from a hash array and destroy everything else.  <a href="sc__containers_8h.html#aaf5b81adba0e4c4c3c557dcf7613f36b">More...</a><br /></td></tr>
<tr class="separator:aaf5b81adba0e4c4c3c557dcf7613f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a953f00fc29ceeed5ee0b0629aa36ec7e">sc_recycle_array_init</a> (<a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *rec_array, size_t elem_size)</td></tr>
<tr class="memdesc:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a recycle array.  <a href="sc__containers_8h.html#a953f00fc29ceeed5ee0b0629aa36ec7e">More...</a><br /></td></tr>
<tr class="separator:a953f00fc29ceeed5ee0b0629aa36ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cade0e4211936ded04e2a2e7df9ca33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a2cade0e4211936ded04e2a2e7df9ca33">sc_recycle_array_reset</a> (<a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *rec_array)</td></tr>
<tr class="memdesc:a2cade0e4211936ded04e2a2e7df9ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a recycle array.  <a href="sc__containers_8h.html#a2cade0e4211936ded04e2a2e7df9ca33">More...</a><br /></td></tr>
<tr class="separator:a2cade0e4211936ded04e2a2e7df9ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40dce6d559ee358c2bb469e64c379d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#adc40dce6d559ee358c2bb469e64c379d">sc_recycle_array_insert</a> (<a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *rec_array, size_t *position)</td></tr>
<tr class="memdesc:adc40dce6d559ee358c2bb469e64c379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into the recycle array.  <a href="sc__containers_8h.html#adc40dce6d559ee358c2bb469e64c379d">More...</a><br /></td></tr>
<tr class="separator:adc40dce6d559ee358c2bb469e64c379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788e8444ddf769046c38afc05bfac38e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__containers_8h.html#a788e8444ddf769046c38afc05bfac38e">sc_recycle_array_remove</a> (<a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *rec_array, size_t position)</td></tr>
<tr class="memdesc:a788e8444ddf769046c38afc05bfac38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from the recycle array.  <a href="sc__containers_8h.html#a788e8444ddf769046c38afc05bfac38e">More...</a><br /></td></tr>
<tr class="separator:a788e8444ddf769046c38afc05bfac38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dynamic containers such as lists, arrays, and hash tables. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae94de2c6227fdb03f497aa2524257003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94de2c6227fdb03f497aa2524257003">&#9670;&nbsp;</a></span>SC_ARRAY_BYTE_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SC_ARRAY_BYTE_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">         ((size_t) \</div>
<div class="line">         (<a class="code" href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a> (a) ? (a)-&gt;byte_alloc : -((a)-&gt;byte_alloc + 1)))</div>
<div class="ttc" id="asc__containers_8h_html_ad9e37c27d608aabb0db95b28ccc27a8d"><div class="ttname"><a href="sc__containers_8h.html#ad9e37c27d608aabb0db95b28ccc27a8d">SC_ARRAY_IS_OWNER</a></div><div class="ttdeci">#define SC_ARRAY_IS_OWNER(a)</div><div class="ttdoc">Test whether the sc_array_t owns its array.</div><div class="ttdef"><b>Definition:</b> sc_containers.h:133</div></div>
</div><!-- fragment -->
<p>Return the allocated size of the array. </p>

</div>
</div>
<a id="a15fd16d6e7d37a678e3e764f68893541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fd16d6e7d37a678e3e764f68893541">&#9670;&nbsp;</a></span>sc_hash_final</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_hash_final</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                              ((void)                            \</div>
<div class="line">                              (c ^= b, c -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(b,14),  \</div>
<div class="line">                               a ^= c, a -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(c,11),  \</div>
<div class="line">                               b ^= a, b -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(a,25),  \</div>
<div class="line">                               c ^= b, c -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(b,16),  \</div>
<div class="line">                               a ^= c, a -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(c, 4),  \</div>
<div class="line">                               b ^= a, b -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(a,14),  \</div>
<div class="line">                               c ^= b, c -= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(b,24)))</div>
<div class="ttc" id="asc__containers_8h_html_ab07c2062a328d6072fa398dcf34df750"><div class="ttname"><a href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a></div><div class="ttdeci">#define sc_hash_rot(x, k)</div><div class="ttdoc">Bijective bit rotation as building block for hash functions.</div><div class="ttdef"><b>Definition:</b> sc_containers.h:56</div></div>
</div><!-- fragment -->
<p>Integer bit operations as building block for hash functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>First in/out value (32-bit integer). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Second in/out value (32-bit integer). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>Third in/out value (32-bit integer). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b111eda1aeb1c0c756c59d001a07caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b111eda1aeb1c0c756c59d001a07caa">&#9670;&nbsp;</a></span>sc_hash_mix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_hash_mix</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                            ((void)                                      \</div>
<div class="line">                            (a -= c, a ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(c, 4), c += b,    \</div>
<div class="line">                             b -= a, b ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(a, 6), a += c,    \</div>
<div class="line">                             c -= b, c ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(b, 8), b += a,    \</div>
<div class="line">                             a -= c, a ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(c,16), c += b,    \</div>
<div class="line">                             b -= a, b ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(a,19), a += c,    \</div>
<div class="line">                             c -= b, c ^= <a class="code" href="sc__containers_8h.html#ab07c2062a328d6072fa398dcf34df750">sc_hash_rot</a>(b, 4), b += a))</div>
</div><!-- fragment -->
<p>Integer bit mixer as building block for hash functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">a</td><td>First in/out value (32-bit integer). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>Second in/out value (32-bit integer). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>Third in/out value (32-bit integer). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab07c2062a328d6072fa398dcf34df750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07c2062a328d6072fa398dcf34df750">&#9670;&nbsp;</a></span>sc_hash_rot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sc_hash_rot</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((x) &lt;&lt; (k)) | ((x) &gt;&gt; (32 - (k))))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bijective bit rotation as building block for hash functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input value (32-bit integer). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Bit shift amount (&lt;= 32). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Circular shifted integer. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a619346753d2a15625bda06835c83e5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619346753d2a15625bda06835c83e5e2">&#9670;&nbsp;</a></span>sc_array_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__array.html">sc_array</a> <a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> object provides a dynamic array of equal-size elements. </p>
<p>Elements are accessed by their 0-based index. Their address may change. The number of elements (== elem_count) of the array can be changed by <a class="el" href="sc__containers_8h.html#a584d8488f231972c68d44eb6239c9cd8">sc_array_resize</a> and <a class="el" href="sc__containers_8h.html#a30ec6fe1bb8a06481c6677e63efc76ec">sc_array_rewind</a>. Elements can be sorted with <a class="el" href="sc__containers_8h.html#a750f7188a30c8c2756c77d70967b0caf">sc_array_sort</a>. If the array is sorted, it can be searched with <a class="el" href="sc__containers_8h.html#aa0759d2b44ed0aadb8c325f7bd5f5449">sc_array_bsearch</a>. A priority queue is implemented with pqueue_add and pqueue_pop (untested). </p>

</div>
</div>
<a id="a783687760fbe3e2c531cd99a695ab7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783687760fbe3e2c531cd99a695ab7e1">&#9670;&nbsp;</a></span>sc_array_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* sc_array_type_t) (<a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *array, size_t index, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine the enumerable type of an object in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>Array containing the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The location of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3afb1f6aca73ea1b310e6d91c65c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3afb1f6aca73ea1b310e6d91c65c36">&#9670;&nbsp;</a></span>sc_equal_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sc_equal_function_t) (const void *v1, const void *v2, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check equality of two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Pointer to first object checked for equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Pointer to second object checked for equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *v1 is unequal *v2 and true otherwise. </dd></dl>

</div>
</div>
<a id="a663eb6e36259a43ad0e583b19e9926c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663eb6e36259a43ad0e583b19e9926c7">&#9670;&nbsp;</a></span>sc_hash_array_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__hash__array.html">sc_hash_array</a> <a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="structsc__hash__array.html" title="The sc_hash_array implements an array backed up by a hash table.">sc_hash_array</a> implements an array backed up by a hash table. </p>
<p>This enables O(1) access for array elements. </p>

</div>
</div>
<a id="a377b6d1c8ddd0e9fd27113be5ac70bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377b6d1c8ddd0e9fd27113be5ac70bf7">&#9670;&nbsp;</a></span>sc_hash_foreach_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* sc_hash_foreach_t) (void **v, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call on every data item of a hash table or hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The address of the pointer to the current object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if the traversal should continue, false to stop. </dd></dl>

</div>
</div>
<a id="a0a303b68788b49895e85f4a80fb061aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a303b68788b49895e85f4a80fb061aa">&#9670;&nbsp;</a></span>sc_hash_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int(* sc_hash_function_t) (const void *v, const void *u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute a hash value of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Arbitrary user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an unsigned integer. </dd></dl>

</div>
</div>
<a id="a7966c694715add48d4d3ac86b330592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7966c694715add48d4d3ac86b330592b">&#9670;&nbsp;</a></span>sc_hash_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__hash.html">sc_hash</a> <a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="structsc__hash.html" title="The sc_hash implements a hash table.">sc_hash</a> implements a hash table. </p>
<p>It uses an array which has linked lists as elements. </p>

</div>
</div>
<a id="a9d4ef6fe706382d2d67a66fba72d0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4ef6fe706382d2d67a66fba72d0bf4">&#9670;&nbsp;</a></span>sc_mempool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__mempool.html">sc_mempool</a> <a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="structsc__mempool.html" title="The sc_mempool object provides a large pool of equal-size elements.">sc_mempool</a> object provides a large pool of equal-size elements. </p>
<p>The pool grows dynamically for element allocation. Elements are referenced by their address which never changes. Elements can be freed (that is, returned to the pool) and are transparently reused. If the zero_and_persist option is selected, new elements are initialized to all zeros on creation, and the contents of an element are not touched between freeing and re-returning it. </p>

</div>
</div>
<a id="ab9cd613ca16520c612c4dd38d0ce3070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cd613ca16520c612c4dd38d0ce3070">&#9670;&nbsp;</a></span>sc_mstamp_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__mstamp.html">sc_mstamp</a> <a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A data container to create memory items of the same size. </p>
<p>Allocations are bundled so it's fast for small memory sizes. The items created will remain valid until the container is destroyed. There is no option to return an item to the container. See <a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> for that purpose. </p>

</div>
</div>
<a id="a135d3d31f993e731607abaad2fd43ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135d3d31f993e731607abaad2fd43ee6">&#9670;&nbsp;</a></span>sc_recycle_array_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsc__recycle__array.html">sc_recycle_array</a> <a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="structsc__recycle__array.html" title="The sc_recycle_array object provides an array of slots that can be reused.">sc_recycle_array</a> object provides an array of slots that can be reused. </p>
<p>It keeps a list of free slots in the array which will be used for insertion while available. Otherwise, the array is grown. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa0759d2b44ed0aadb8c325f7bd5f5449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0759d2b44ed0aadb8c325f7bd5f5449">&#9670;&nbsp;</a></span>sc_array_bsearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sc_array_bsearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary search on an array. </p>
<p>The array must be sorted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>A sorted array to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>An element to be searched for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index into array for the item found, or -1. </dd></dl>

</div>
</div>
<a id="aff8a3c56854a5efc06605541278ea3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8a3c56854a5efc06605541278ea3dd">&#9670;&nbsp;</a></span>sc_array_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sc_array_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the adler32 checksum of array data (see zlib documentation). </p>
<p>This is a faster checksum than crc32, and it works with zeros as data. </p>

</div>
</div>
<a id="a396352376b97fd861557f4b844ba0730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396352376b97fd861557f4b844ba0730">&#9670;&nbsp;</a></span>sc_array_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of one array into another. </p>
<p>Both arrays must have equal element sizes. The source array may be a view. We use memcpy (3): If the two arrays overlap, results are undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Array (not a view) will be resized and get new data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array used as source of new data, will not be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6838c27c4655cb9e3637e2277be1371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6838c27c4655cb9e3637e2277be1371">&#9670;&nbsp;</a></span>sc_array_copy_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_copy_into </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of one array into some portion of another. </p>
<p>Both arrays must have equal element sizes. Either array may be a view. The destination array must be large enough. We use memcpy (3): If the two arrays overlap, results are undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Array will be written into. Its element count must be at least <b>dest_offset</b> + <b>src-&gt;elem_count</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_offset</td><td>First index in <b>dest</b> array to be overwritten. As every index, it refers to elements, not bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array used as source of new data, will not be changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9538f758ce0adf6f61c7091dff1a693a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9538f758ce0adf6f61c7091dff1a693a">&#9670;&nbsp;</a></span>sc_array_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an array structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66a53cdb69696fe2dbf8dd8dda821155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a53cdb69696fe2dbf8dd8dda821155">&#9670;&nbsp;</a></span>sc_array_destroy_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_destroy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> **&#160;</td>
          <td class="paramname"><em>parray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an array structure and sets the pointer to NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parray</td><td>Pointer to address of array to be destroyed. On output, *parray is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a253a39f46eda1adfc12871e3e52e2251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253a39f46eda1adfc12871e3e52e2251">&#9670;&nbsp;</a></span>sc_array_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) array structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab123c042db61b86447f9c68edff6c275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab123c042db61b86447f9c68edff6c275">&#9670;&nbsp;</a></span>sc_array_init_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) array structure and allocates a given number of elements. </p>
<p>This function supersedes <a class="el" href="sc__containers_8h.html#a34588e4788f67b33bea0c99dc34e0473">sc_array_init_size</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>Number of initial array elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a314b3cdbde02bc48303c9d60391286ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314b3cdbde02bc48303c9d60391286ee">&#9670;&nbsp;</a></span>sc_array_init_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) view from given plain C data. </p>
<p>The array view returned does not require sc_array_reset (doesn't hurt though). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">view</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The data must not be moved while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>The length of the view in element units. The view cannot be resized to exceed this length. It is not necessary to call sc_array_reset later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a225c9354782d37590e63d704124cd113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225c9354782d37590e63d704124cd113">&#9670;&nbsp;</a></span>sc_array_init_reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an already allocated (or static) view from existing sc_array_t. </p>
<p>The total data size of the view is the same, but size and count may differ. The array view returned does not require sc_array_reset (doesn't hurt though). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">view</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array must not be resized while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element of the view in bytes. The product of size and count of <em>array</em> must be the same as <em>elem_size</em> * <em>elem_count</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>The length of the view in element units. The view cannot be resized to exceed this length. It is not necessary to call sc_array_reset later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34588e4788f67b33bea0c99dc34e0473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34588e4788f67b33bea0c99dc34e0473">&#9670;&nbsp;</a></span>sc_array_init_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) array structure and allocates a given number of elements. </p>
<p>Deprecated: use <a class="el" href="sc__containers_8h.html#ab123c042db61b86447f9c68edff6c275">sc_array_init_count</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>Number of initial array elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c755a6fdc7f4e3c490d9edb786cc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c755a6fdc7f4e3c490d9edb786cc5d">&#9670;&nbsp;</a></span>sc_array_init_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_init_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already allocated (or static) view from existing sc_array_t. </p>
<p>The array view returned does not require sc_array_reset (doesn't hurt though). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">view</td><td>Array structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array must not be resized while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset of the viewed section in element units. This offset cannot be changed until the view is reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the view in element units. The view cannot be resized to exceed this length. It is not necessary to call sc_array_reset later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc880037e9e90efb76648a5faa926e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc880037e9e90efb76648a5faa926e5b">&#9670;&nbsp;</a></span>sc_array_is_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether two arrays have equal size, count, and content. </p>
<p>Either array may be a view. Both arrays will not be changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>One array to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>A second array to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if array and other are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="aba51287db7e298935bd1fda5557fbacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba51287db7e298935bd1fda5557fbacf">&#9670;&nbsp;</a></span>sc_array_is_permutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether <em>array</em> is an array of size_t's whose entries include every integer 0 &lt;= i &lt; array-&gt;elem_count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>An array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if array contains size_t elements whose entries include every integer 0 &lt;= i &lt; <em>array-&gt;elem_count</em>, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ab930cdd0da30cd639b20a639990568e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab930cdd0da30cd639b20a639990568e1">&#9670;&nbsp;</a></span>sc_array_is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_array_is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the array is sorted wrt. </p>
<p>the comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if array is sorted, false otherwise. </dd></dl>

</div>
</div>
<a id="a9c156f095e1050cd568689fa3615a7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c156f095e1050cd568689fa3615a7ed">&#9670;&nbsp;</a></span>sc_array_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_dynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_dynamic</td><td>True if created with sc_array_new, false if initialized with sc_array_init </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a id="aacb264d085512739969ce4fb6d643d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb264d085512739969ce4fb6d643d7a">&#9670;&nbsp;</a></span>sc_array_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run memset on the array storage. </p>
<p>We pass the character to memset unchanged. Thus, care must be taken when setting values below -1 or above 127, just as with standard memset (3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>This array's storage will be overwritten. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Character to overwrite every byte with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d66f0bf86f9f8975611dda4d0b2880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d66f0bf86f9f8975611dda4d0b2880">&#9670;&nbsp;</a></span>sc_array_move_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_move_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy part of one array into another using memmove (3). </p>
<p>Both arrays must have equal element sizes. Either array may be a view. The destination array must be large enough. We use memmove (3): The two arrays may overlap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Array will be written into. Its element count must be at least <b>dest_offset</b> + <b>count</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_offset</td><td>First index in <b>dest</b> array to be overwritten. As every index, it refers to elements, not bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array will be read from. Its element count must be at least <b>src_offset</b> + <b>count</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_offset</td><td>First index in <b>src</b> array to be used. As every index, it refers to elements, not bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of entries copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad880facede1dd567bd4da71fc8b46dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad880facede1dd567bd4da71fc8b46dcd">&#9670;&nbsp;</a></span>sc_array_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a>* sc_array_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new array structure with 0 elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return an allocated array of zero length. </dd></dl>

</div>
</div>
<a id="a995cca28e6413132e14691834e279504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995cca28e6413132e14691834e279504">&#9670;&nbsp;</a></span>sc_array_new_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a>* sc_array_new_count </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new array structure with a given length (number of elements). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>Initial number of array elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return an allocated array with allocated but uninitialized elements. </dd></dl>

</div>
</div>
<a id="a45ac4f8d8add15a6838cb0ec9c3319be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ac4f8d8add15a6838cb0ec9c3319be">&#9670;&nbsp;</a></span>sc_array_new_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a>* sc_array_new_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new view of an existing plain C array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The data must not be moved while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_count</td><td>The length of the view in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acff8923e5659a46da89edfabb089d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff8923e5659a46da89edfabb089d3f4">&#9670;&nbsp;</a></span>sc_array_new_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a>* sc_array_new_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new view of an existing sc_array_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array must not be resized while view is alive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset of the viewed section in element units. This offset cannot be changed until the view is reset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the viewed section in element units. The view cannot be resized to exceed this length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05188345c402a4374c9e7ed4753e5c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05188345c402a4374c9e7ed4753e5c8e">&#9670;&nbsp;</a></span>sc_array_permute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>newindices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keepperm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given permutation <em>newindices</em>, permute <em>array</em> in place. </p>
<p>The data that on input is contained in <em>array</em>[i] will be contained in <em>array</em>[newindices[i]] on output. The entries of newindices will be altered unless <em>keepperm</em> is true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>An array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newindices</td><td>Permutation array (see sc_array_is_permutation). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keepperm</td><td>If true, <em>newindices</em> will be unchanged by the algorithm; if false, <em>newindices</em> will be the identity permutation on output, but the algorithm will only use O(1) space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadd0c405a3d83dfc251de2a390f43d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd0c405a3d83dfc251de2a390f43d88">&#9670;&nbsp;</a></span>sc_array_pqueue_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_pqueue_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to a priority queue. </p>
<dl class="section note"><dt>Note</dt><dd>PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. The priority queue is implemented as a heap in ascending order. A heap is a binary tree where the children are not less than their parent. Assumes that elements [0]..[elem_count-2] form a valid heap. Then propagates [elem_count-1] upward by swapping if necessary. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Valid priority queue object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>Pointer to unused allocated memory of elem_size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of swap operations. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the return value is zero for all elements in an array, the array is sorted linearly and unchanged. </dd></dl>

</div>
</div>
<a id="af8ec1c3d19267b204a2f756fe428f196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ec1c3d19267b204a2f756fe428f196">&#9670;&nbsp;</a></span>sc_array_pqueue_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_array_pqueue_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops the smallest element from a priority queue. </p>
<dl class="section note"><dt>Note</dt><dd>PQUEUE FUNCTIONS ARE UNTESTED AND CURRENTLY DISABLED. This function is not allowed for views. This function assumes that the array forms a valid heap in ascending order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Valid priority queue object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to unused allocated memory of elem_size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of swap operations. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function resizes the array to elem_count-1. </dd></dl>

</div>
</div>
<a id="a6df54afbedf05d9cf789c5ebb7599ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df54afbedf05d9cf789c5ebb7599ab4">&#9670;&nbsp;</a></span>sc_array_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the array count to zero and frees all elements. </p>
<p>This function turns a view into a newly initialized array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling sc_array_init, then any array operations, then sc_array_reset is memory neutral. As an exception, the two functions sc_array_init_view and sc_array_init_data do not require a subsequent call to sc_array_reset. Regardless, it is legal to call sc_array_reset anyway. </dd></dl>

</div>
</div>
<a id="a584d8488f231972c68d44eb6239c9cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584d8488f231972c68d44eb6239c9cd8">&#9670;&nbsp;</a></span>sc_array_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the element count to new_count. </p>
<p>If the array is not a view, reallocation takes place occasionally. If the array is a view, new_count must not be greater than the element count of the view when it was created. The original offset of the view cannot be changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The element count and address is modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_count</td><td>New element count of the array. If it is zero and the array is not a view, the effect equals <a class="el" href="sc__containers_8h.html#a6df54afbedf05d9cf789c5ebb7599ab4">sc_array_reset</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ec6fe1bb8a06481c6677e63efc76ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ec6fe1bb8a06481c6677e63efc76ec">&#9670;&nbsp;</a></span>sc_array_rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorten an array without reallocating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The element count of this array is modified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_count</td><td>Must be less or equal than the <b>array's</b> count. If it is less, the number of elements in the array is reduced without reallocating memory. The exception is a <b>new_count</b> of zero specified for an array that is not a view: In this case <a class="el" href="sc__containers_8h.html#a6df54afbedf05d9cf789c5ebb7599ab4">sc_array_reset</a> is equivalent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a750f7188a30c8c2756c77d70967b0caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750f7188a30c8c2756c77d70967b0caf">&#9670;&nbsp;</a></span>sc_array_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the array in ascending order wrt. </p>
<p>the comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The array to sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ef2072803b22a940c6e39498940768c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef2072803b22a940c6e39498940768c">&#9670;&nbsp;</a></span>sc_array_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a783687760fbe3e2c531cd99a695ab7e1">sc_array_type_t</a>&#160;</td>
          <td class="paramname"><em>type_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the offsets of groups of enumerable types in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>Array that is sorted in ascending order by type. If k indexes <em>array</em>, then 0 &lt;= <em>type_fn</em> (<em>array</em>, k, <em>data</em>) &lt; <em>num_types</em>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>An initialized array of type size_t that is resized to <em>num_types</em> + 1 entries. The indices j of <em>array</em> that contain objects of type k are <em>offsets</em>[k] &lt;= j &lt; <em>offsets</em>[k + 1]. If there are no objects of type k, then <em>offsets</em>[k] = <em>offset</em>[k + 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_types</td><td>The number of possible types of objects in <em>array</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type_fn</td><td>Returns the type of an object in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Arbitrary user data passed to <em>type_fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd6536ee67b1b02848dd529ffd1e3fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6536ee67b1b02848dd529ffd1e3fec">&#9670;&nbsp;</a></span>sc_array_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the array count to zero, but does not free elements. </p>
<p>Not allowed for views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>Array structure to be truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is intended to allow an <a class="el" href="structsc__array.html" title="The sc_array object provides a dynamic array of equal-size elements.">sc_array</a> to be used as a reusable buffer, where the "high water mark" of the buffer is preserved, so that O(log (max n)) reallocs occur over the life of the buffer. </dd></dl>

</div>
</div>
<a id="a7be396714f4ea39005cab1bc666666a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be396714f4ea39005cab1bc666666a6">&#9670;&nbsp;</a></span>sc_array_uniq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_array_uniq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removed duplicate entries from a sorted array. </p>
<p>This function is not allowed for views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array size will be reduced as necessary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compar</td><td>The comparison function to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe72e9f693035fffc01e42dbd1f52859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe72e9f693035fffc01e42dbd1f52859">&#9670;&nbsp;</a></span>sc_hash_array_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Valid hash array is deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d905b28782d768b687cd0bf0d75cf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d905b28782d768b687cd0bf0d75cf5a">&#9670;&nbsp;</a></span>sc_hash_array_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">sc_hash_foreach_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a callback for every member of the hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Valid hash array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>Callback executed on every hash array element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc4c1933168da0ac3b075df053ceab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc4c1933168da0ac3b075df053ceab3">&#9670;&nbsp;</a></span>sc_hash_array_insert_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_hash_array_insert_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into a hash array if it is not contained already. </p>
<p>The object is not copied into the array. Use the return value for that. New objects are guaranteed to be added at the end of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Valid hash array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the object. Used for search only. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the already contained, or if not present, the new object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL if the object is already contained. Otherwise returns its new address in the array. </dd></dl>

</div>
</div>
<a id="ac36fbe3c869bded837f9976c20ea7b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36fbe3c869bded837f9976c20ea7b95">&#9670;&nbsp;</a></span>sc_hash_array_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_array_is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the internal consistency of a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_array</td><td>Hash array structure is checked for validity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if <em>hash_array</em> is valid. </dd></dl>

</div>
</div>
<a id="a1743a8aa716313f45e754b05f4066d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1743a8aa716313f45e754b05f4066d07">&#9670;&nbsp;</a></span>sc_hash_array_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_array_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an object is contained in a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Valid hash array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the already contained object if found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if object is found, false otherwise. </dd></dl>

</div>
</div>
<a id="a287e5cf0f7ea5b4a16e534a19fffa595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287e5cf0f7ea5b4a16e534a19fffa595">&#9670;&nbsp;</a></span>sc_hash_array_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_hash_array_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>ha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ha</td><td>The hash array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a id="aa086b8ede8a18ebdcfb690d6bf73e86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa086b8ede8a18ebdcfb690d6bf73e86a">&#9670;&nbsp;</a></span>sc_hash_array_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a>* sc_hash_array_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">sc_hash_function_t</a>&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">sc_equal_function_t</a>&#160;</td>
          <td class="paramname"><em>equal_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one array element in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_fn</td><td>Function to compute the hash value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equal_fn</td><td>Function to test two objects for equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Anonymous context data stored in the hash array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf5b81adba0e4c4c3c557dcf7613f36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5b81adba0e4c4c3c557dcf7613f36b">&#9670;&nbsp;</a></span>sc_hash_array_rip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_rip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a619346753d2a15625bda06835c83e5e2">sc_array_t</a> *&#160;</td>
          <td class="paramname"><em>rip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the array data from a hash array and destroy everything else. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_array</td><td>The hash array is destroyed after extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rip</td><td>Array structure that will be overwritten. All previous array data (if any) will be leaked. The filled array can be freed with sc_array_reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8557bf638bc729901df79c86f05e04c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8557bf638bc729901df79c86f05e04c4">&#9670;&nbsp;</a></span>sc_hash_array_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_array_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a663eb6e36259a43ad0e583b19e9926c7">sc_hash_array_t</a> *&#160;</td>
          <td class="paramname"><em>hash_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from the hash array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash_array</td><td>Hash array to truncate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4485f83fdfee14e4a14573f4efe7c108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485f83fdfee14e4a14573f4efe7c108">&#9670;&nbsp;</a></span>sc_hash_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a hash table. </p>
<p>If the allocator is owned, this runs in O(1), otherwise in O(N). </p><dl class="section note"><dt>Note</dt><dd>If allocator was provided in sc_hash_new, it will not be destroyed. </dd></dl>

</div>
</div>
<a id="a50845e587caa053395c696b4fdb274e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50845e587caa053395c696b4fdb274e1">&#9670;&nbsp;</a></span>sc_hash_destroy_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_destroy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> **&#160;</td>
          <td class="paramname"><em>phash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a hash table and set its pointer to NULL. </p>
<p>Destruction is done using <a class="el" href="sc__containers_8h.html#a4485f83fdfee14e4a14573f4efe7c108">sc_hash_destroy</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">phash</td><td>Address of pointer to hash table. On output, pointer is NULLed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accbe548fa780a3d3ce1a719075eb3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbe548fa780a3d3ce1a719075eb3d5a">&#9670;&nbsp;</a></span>sc_hash_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a377b6d1c8ddd0e9fd27113be5ac70bf7">sc_hash_foreach_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a callback for every member of the hash table. </p>
<p>The hashing and equality functions are not called from within this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Valid hash table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>Callback executed on every hash table element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f50ed06f72928a512bf013da66231dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f50ed06f72928a512bf013da66231dd">&#9670;&nbsp;</a></span>sc_hash_function_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sc_hash_function_string </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a hash value from a null-terminated string. </p>
<p>This hash function is NOT cryptographically safe! Use libcrypt then. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Null-terminated string to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed hash value as an unsigned integer. </dd></dl>

</div>
</div>
<a id="a471ac510c147c97b396a980d7cfc6852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471ac510c147c97b396a980d7cfc6852">&#9670;&nbsp;</a></span>sc_hash_insert_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_insert_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into a hash table if it is not contained already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Valid hash table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be inserted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the address of the pointer to the already contained, or if not present, the new object. You can assign to **found to override. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is added, false if it is already contained. </dd></dl>

</div>
</div>
<a id="ac491f058bd4a47555c203e94db47f37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac491f058bd4a47555c203e94db47f37c">&#9670;&nbsp;</a></span>sc_hash_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an object is contained in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Valid hash table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be looked up. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the address of the pointer to the already contained object if the object is found. You can assign to **found to override. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is found, false otherwise. </dd></dl>

</div>
</div>
<a id="a61448f834b749daa38248ad391417e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61448f834b749daa38248ad391417e0a">&#9670;&nbsp;</a></span>sc_hash_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_hash_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>The hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a id="a79301891a134c0765dd8770cd88545d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79301891a134c0765dd8770cd88545d1">&#9670;&nbsp;</a></span>sc_hash_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a>* sc_hash_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0a303b68788b49895e85f4a80fb061aa">sc_hash_function_t</a>&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#afa3afb1f6aca73ea1b310e6d91c65c36">sc_equal_function_t</a>&#160;</td>
          <td class="paramname"><em>equal_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hash table. </p>
<p>The number of hash slots is chosen dynamically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_fn</td><td>Function to compute the hash value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equal_fn</td><td>Function to test two objects for equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed through to the hash function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator for sc_link_t, can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1b5d86966197595ae5ecd9471af8e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b5d86966197595ae5ecd9471af8e05">&#9670;&nbsp;</a></span>sc_hash_print_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_print_statistics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>package_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>log_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and print statistical information about the occupancy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">package_id</td><td>Library package id for logging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_priority</td><td>Priority for logging; see <a class="el" href="sc_8h.html#a4fae12646e51b0ec8755db8c1e6c323e">sc_log</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Valid hash table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3368ef4a371e8128a96e159ea28c3c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3368ef4a371e8128a96e159ea28c3c63">&#9670;&nbsp;</a></span>sc_hash_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sc_hash_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an object from a hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Valid hash table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The object to be removed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>If found != NULL, *found is set to the object that is removed if that exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if object is found, false if is not contained. </dd></dl>

</div>
</div>
<a id="a6018b3a4e5c51501d52094335bb85d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6018b3a4e5c51501d52094335bb85d11">&#9670;&nbsp;</a></span>sc_hash_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all entries from a hash table in O(N). </p>
<p>If the allocator is owned, it calls sc_hash_unlink and sc_mempool_truncate. Otherwise, it calls sc_list_reset on every hash slot which is slower. </p>

</div>
</div>
<a id="ab2992a0fc01581345b413f460a4b7927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2992a0fc01581345b413f460a4b7927">&#9670;&nbsp;</a></span>sc_hash_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink all hash elements without returning them to the mempool. </p>
<p>If the allocator is not owned, this runs faster than sc_hash_truncate, but is dangerous because of potential memory leaks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Hash structure to be unlinked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6fe8987fef58946b5327ea202cfb9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fe8987fef58946b5327ea202cfb9c7">&#9670;&nbsp;</a></span>sc_hash_unlink_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_hash_unlink_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a7966c694715add48d4d3ac86b330592b">sc_hash_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same effect as unlink and destroy, but in O(1). </p>
<p>This is dangerous because of potential memory leaks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Hash structure to be unlinked and destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfae475a3fb1f3fe8e0f5a7548262065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfae475a3fb1f3fe8e0f5a7548262065">&#9670;&nbsp;</a></span>sc_list_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a>* sc_list_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a list element at the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>Valid list object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A new link is created holding this data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The link that has been created for data. </dd></dl>

</div>
</div>
<a id="ab9d366868c0011ee034b4e1b5d6f701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d366868c0011ee034b4e1b5d6f701f">&#9670;&nbsp;</a></span>sc_list_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a linked list structure in O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>All memory allocated for this list is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If allocator was provided in sc_list_new, it will not be destroyed. </dd></dl>

</div>
</div>
<a id="a2345f4f800f46d60d612c6d9545758dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2345f4f800f46d60d612c6d9545758dd">&#9670;&nbsp;</a></span>sc_list_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a list object with an external link allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>External memory allocator for sc_link_t, which must exist already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b94f6cf468b02dbaabd780e162cbeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b94f6cf468b02dbaabd780e162cbeaa">&#9670;&nbsp;</a></span>sc_list_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a>* sc_list_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element after a given list position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>Valid list object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pred</td><td>The predecessor of the element to be inserted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A new link is created holding this data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The link that has been created for data. </dd></dl>

</div>
</div>
<a id="abc4ec6b2855dcb3125310f6ad2928ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4ec6b2855dcb3125310f6ad2928ca1">&#9670;&nbsp;</a></span>sc_list_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_list_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_dynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total memory used by a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_dynamic</td><td>True if created with sc_list_new, false if initialized with sc_list_init </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a id="a16ed388e36eb3088d911d68f995be3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ed388e36eb3088d911d68f995be3b1">&#9670;&nbsp;</a></span>sc_list_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a>* sc_list_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new, empty linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>Memory allocator for sc_link_t, can be NULL in which case an internal allocator is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a newly allocated, empty list object. </dd></dl>

</div>
</div>
<a id="affcaa9043e79854360ab37bdc670e668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcaa9043e79854360ab37bdc670e668">&#9670;&nbsp;</a></span>sc_list_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_list_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element from the front of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>Valid, non-empty list object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the data of the removed first list element. </dd></dl>

</div>
</div>
<a id="a6d609be9c0904f955ea15eddab01ef12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d609be9c0904f955ea15eddab01ef12">&#9670;&nbsp;</a></span>sc_list_prepend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a>* sc_list_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a list element at the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>Valid list object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A new link is created holding this data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The link that has been created for data. </dd></dl>

</div>
</div>
<a id="aaf1dfcc941294ac2b6898db6b798938d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1dfcc941294ac2b6898db6b798938d">&#9670;&nbsp;</a></span>sc_list_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a88fdd18bc0086f8cdba6971f505dcbb0">sc_link_t</a> *&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an element after a given list position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>Valid, non-empty list object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pred</td><td>The predecessor of the element to be removed. If <em>pred</em> == NULL, the first element is removed, which is equivalent to calling sc_list_pop (list). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data of the removed and freed link. </dd></dl>

</div>
</div>
<a id="ab87b22d2b61f04d3c73d93e9218b97c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87b22d2b61f04d3c73d93e9218b97c7">&#9670;&nbsp;</a></span>sc_list_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements from a list in O(N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be emptied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling sc_list_init, then any list operations, then sc_list_reset is memory neutral. </dd></dl>

</div>
</div>
<a id="a5934247f1587a5376772ec2d035f812f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5934247f1587a5376772ec2d035f812f">&#9670;&nbsp;</a></span>sc_list_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_list_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a0d7968381a6d40057f3af6acec771a70">sc_list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlink all list elements without returning them to the mempool. </p>
<p>This runs in O(1) but is dangerous because the link memory stays alive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>List structure to be unlinked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ecbb2b02cf93632c79c7307f5238ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ecbb2b02cf93632c79c7307f5238ba">&#9670;&nbsp;</a></span>sc_mempool_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mempool structure. </p>
<p>All elements that are still in use are invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mempool</td><td>Its memory is freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81b560f3010038ed71dad8635eb747fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b560f3010038ed71dad8635eb747fd">&#9670;&nbsp;</a></span>sc_mempool_destroy_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_destroy_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> **&#160;</td>
          <td class="paramname"><em>pmempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mempool structure. </p>
<p>All elements that are still in use are invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pmempool</td><td>Address of pointer to memory pool. Its memory is freed, pointer is NULLed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac8778c147e092b73df13afdbc2e4c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8778c147e092b73df13afdbc2e4c84">&#9670;&nbsp;</a></span>sc_mempool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as sc_mempool_new, but for an already allocated object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mempool</td><td>Allocated memory is overwritten and initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one element in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73235130bba53a9ed8b07ddfa27fadae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73235130bba53a9ed8b07ddfa27fadae">&#9670;&nbsp;</a></span>sc_mempool_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_mempool_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the memory used by a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mempool</td><td>The memory pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory used in bytes. </dd></dl>

</div>
</div>
<a id="ab416c24d85ffd174f0dd3ad89c4c1163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab416c24d85ffd174f0dd3ad89c4c1163">&#9670;&nbsp;</a></span>sc_mempool_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a>* sc_mempool_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mempool structure with the zero_and_persist option off. </p>
<p>The contents of any elements returned by sc_mempool_alloc are undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one element in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an allocated and initialized memory pool. </dd></dl>

</div>
</div>
<a id="a561743511cacdfaacb29ad28442a5a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561743511cacdfaacb29ad28442a5a4c">&#9670;&nbsp;</a></span>sc_mempool_new_zero_and_persist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a>* sc_mempool_new_zero_and_persist </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new mempool structure with the zero_and_persist option on. </p>
<p>The memory of newly created elements is zero'd out, and the contents of an element are not touched between freeing and re-returning it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of one element in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an allocated and initialized memory pool. </dd></dl>

</div>
</div>
<a id="a1e2a7bbce18983023e61ff681e66d94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2a7bbce18983023e61ff681e66d94f">&#9670;&nbsp;</a></span>sc_mempool_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as sc_mempool_destroy, but does not free the pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mempool</td><td>Valid mempool object is deallocated. The structure memory itself stays alive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab483d01f1670c336d9cf76a8a2789d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab483d01f1670c336d9cf76a8a2789d21">&#9670;&nbsp;</a></span>sc_mempool_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mempool_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a9d4ef6fe706382d2d67a66fba72d0bf4">sc_mempool_t</a> *&#160;</td>
          <td class="paramname"><em>mempool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates all previously returned pointers, resets count to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mempool</td><td>Valid mempool is truncated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9d1bec5cb6c6826ff4095e3052437bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d1bec5cb6c6826ff4095e3052437bf">&#9670;&nbsp;</a></span>sc_mstamp_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_mstamp_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new item. </p>
<p>The memory returned will stay legal until container is destroyed or truncated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mst</td><td>Properly initialized stamp container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an item ready to use. Legal until <a class="el" href="sc__containers_8h.html#a3e36faece884b10645816c2b85cd6a27">sc_mstamp_reset</a> or <a class="el" href="sc__containers_8h.html#a9e50a88d5c99bc2a7f1749a77fe26641">sc_mstamp_truncate</a> is called on mst. </dd></dl>

</div>
</div>
<a id="ac9a667b4bf2d1777550917a00ca1ee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a667b4bf2d1777550917a00ca1ee46">&#9670;&nbsp;</a></span>sc_mstamp_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mstamp_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stamp_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a memory stamp container. </p>
<p>We provide allocation of fixed-size memory items without allocating new memory in every request. Instead we block the allocations in what we call a stamp of multiple items. Even if no allocations are done, the container's internal memory must be freed eventually by <a class="el" href="sc__containers_8h.html#a3e36faece884b10645816c2b85cd6a27">sc_mstamp_reset</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mst</td><td>Legal pointer to a stamp structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stamp_unit</td><td>Size of each memory block that we allocate. If it is larger than the element size, we may place more than one element in it. Passing 0 is legal and forces stamps that hold one item each. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of each item. Passing 0 is legal. In that case, <a class="el" href="sc__containers_8h.html#af9d1bec5cb6c6826ff4095e3052437bf">sc_mstamp_alloc</a> returns NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41fa1c49411f637464a99522a3370145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fa1c49411f637464a99522a3370145">&#9670;&nbsp;</a></span>sc_mstamp_memory_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sc_mstamp_memory_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return memory size in bytes of all data allocated in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mst</td><td>Properly initialized stamp container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total container memory size in bytes. </dd></dl>

</div>
</div>
<a id="a3e36faece884b10645816c2b85cd6a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e36faece884b10645816c2b85cd6a27">&#9670;&nbsp;</a></span>sc_mstamp_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mstamp_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all memory in a stamp structure and all items previously returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mst</td><td>Properly initialized stamp container. On output, the structure is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e50a88d5c99bc2a7f1749a77fe26641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e50a88d5c99bc2a7f1749a77fe26641">&#9670;&nbsp;</a></span>sc_mstamp_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_mstamp_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#ab9cd613ca16520c612c4dd38d0ce3070">sc_mstamp_t</a> *&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all memory in a stamp structure and initialize it anew. </p>
<p>Equivalent to calling <a class="el" href="sc__containers_8h.html#a3e36faece884b10645816c2b85cd6a27">sc_mstamp_reset</a> followed by <a class="el" href="sc__containers_8h.html#ac9a667b4bf2d1777550917a00ca1ee46">sc_mstamp_init</a> with the same stamp_unit and elem_size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mst</td><td>Properly initialized stamp container. On output, its elements have been freed and it is ready for further use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953f00fc29ceeed5ee0b0629aa36ec7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f00fc29ceeed5ee0b0629aa36ec7e">&#9670;&nbsp;</a></span>sc_recycle_array_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_recycle_array_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a recycle array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rec_array</td><td>Uninitialized turned into a recycle array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elem_size</td><td>Size of the objects to be stored in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc40dce6d559ee358c2bb469e64c379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc40dce6d559ee358c2bb469e64c379d">&#9670;&nbsp;</a></span>sc_recycle_array_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_recycle_array_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an object into the recycle array. </p>
<p>The object is not copied into the array. Use the return value for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec_array</td><td>Valid recycle array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>If position != NULL, *position is set to the array position of the inserted object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new address of the object in the array. </dd></dl>

</div>
</div>
<a id="a788e8444ddf769046c38afc05bfac38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788e8444ddf769046c38afc05bfac38e">&#9670;&nbsp;</a></span>sc_recycle_array_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sc_recycle_array_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an object from the recycle array. </p>
<p>It must be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec_array</td><td>Valid recycle array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Index into the array for the object to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the removed object. Will be valid as long as no other function is called on this recycle array. </dd></dl>

</div>
</div>
<a id="a2cade0e4211936ded04e2a2e7df9ca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cade0e4211936ded04e2a2e7df9ca33">&#9670;&nbsp;</a></span>sc_recycle_array_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sc_recycle_array_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sc__containers_8h.html#a135d3d31f993e731607abaad2fd43ee6">sc_recycle_array_t</a> *&#160;</td>
          <td class="paramname"><em>rec_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a recycle array. </p>
<p>As with all _reset functions, calling _init, then any array operations, then _reset is memory neutral. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
